#ifndef QUEX_INCLUDE_GUARD__QUEX__OPERATIONS
#define QUEX_INCLUDE_GUARD__QUEX__OPERATIONS


#define QUEX_MIN(X, Y)  ((X) < (Y) ? (X) : (Y))
#define QUEX_MAX(X, Y)  ((X) > (Y) ? (X) : (Y))

/* Hash Function:
 *
 * Using Dan Bernstein's 'dbj2' (published in comp.lang.c) which is extremely
 * fast but still behaves well. See Linear Congruential Generators for further
 * reading.                                                                  */
#define QUEX_HASH_INIT_VALUE  5381
#define QUEX_HASH_NEXT(H, C)  ((((H) << 5) + (H)) + (C))

#define QUEX_LEXEME_TERMINATING_ZERO_SET(BUFFER)                \
     do { (BUFFER)->_lexatom_at_lexeme_start = (BUFFER)->_read_p[0]; \
          (BUFFER)->_read_p[0]               = (QUEX_TYPE_LEXATOM)0; } while(0)

#define QUEX_LEXEME_TERMINATING_ZERO_UNDO(BUFFER)                                 \
     /* only need to reset, in case that the terminating zero was set*/           \
     if( (BUFFER)->_lexatom_at_lexeme_start != (QUEX_TYPE_LEXATOM)0 ) {           \
         /* NOTE:                                                              */ \
         /*                                                                    */ \
         /*    __quex_assert(*((BUFFER)->_read_p) == (QUEX_TYPE_LEXATOM)0);    */ \
         /*                                                                    */ \
         /* CANNOT hold, since by 'seeking' during backward lexing the read_p  */ \
         /* might actually be loaded out and in again without setting zero.    */ \
         (BUFFER)->_read_p[0]               = (BUFFER)->_lexatom_at_lexeme_start; \
         (BUFFER)->_lexatom_at_lexeme_start = (QUEX_TYPE_LEXATOM)0;               \
     }

#endif /* QUEX_INCLUDE_GUARD__QUEX__OPERATIONS */
