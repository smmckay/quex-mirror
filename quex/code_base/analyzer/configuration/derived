/* Assert Strategy:
 *
 * Asserts are enabled by default. The lexer emits a warning message and tells
 * how to deactivate them. Asserts can be DEACTIVATED as follows.
 *
 *  'NDEBUG' (from Standard 'assert.h') => avoid surprises.
 *  'QUEX_OPTION_ASSERTS_DISABLED_EXT'  => solely prevent Quex's asserts.     
 *                                                                            */
#if   defined(NDEBUG) 
#   ifdef     QUEX_OPTION_ASSERTS_EXT
#      warning "undef of QUEX_OPTION_ASSERTS_EXT triggered by 'NDEBUG'"
#      undef  QUEX_OPTION_ASSERTS_EXT
#   endif
#elif defined(QUEX_OPTION_ASSERTS_DISABLED_EXT)
#   ifdef     QUEX_OPTION_ASSERTS_EXT
#      warning "undef of QUEX_OPTION_ASSERTS_EXT triggered by 'QUEX_OPTION_ASSERTS_DISABLED_EXT'"
#      undef  QUEX_OPTION_ASSERTS_EXT
#   endif
#else
#   ifndef    QUEX_OPTION_ASSERTS_EXT
#      define QUEX_OPTION_ASSERTS_EXT
#   endif
#endif

#define __QUEX_PURE_RETURN   do { return; } while(0)

#if  ! defined (QUEX_SETTING_BUFFER_MIN_FALLBACK_N)
#   if ! defined (QUEX_SETTING_BUFFER_SIZE) 
#      error "QUEX_SETTING_BUFFER_SIZE not defined at this place."
/* If compiler complains here, then 'QUEX_SETTING_BUFFER_SIZE' has probably
 * be defined as something different than an integer. Definitions like
 *
 *   #define QUEX_SETTING_BUFFER_SIZE  (size_t)4096
 *
 * would be proper, but disables some math operations. Anything not-a-number
 * must be deleted from the QUEX_SETTING_BUFFER_SIZE definition.              */
#   elif      QUEX_SETTING_BUFFER_SIZE >= 1024
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (256)
#   elif      QUEX_SETTING_BUFFER_SIZE >= 16
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (size_t)(QUEX_SETTING_BUFFER_SIZE >> 5)
#   else
#      define QUEX_SETTING_BUFFER_MIN_FALLBACK_N  (0)
#   endif
#endif

#define __QUEX_RETURN                                return

/* Default Counter Rules */
#if ! defined(__QUEX_COUNTER_RULES)
    /* NOTE: 'x - x % 4' == 'x with the last two bits deleted'
     *                   == 'x & (~3)'                          */
#   if QUEX_SETTING_CHAR_CODEC == utf8
#       define __QUEX_COUNTER_RULES(counter, iterator)                    \
               switch( (int)(*iterator) ) {                               \
               case (int)(QUEX_TYPE_LEXATOM)'\t':                       \
                   (counter)._column_number_at_end &= (~(size_t)0x3) + 4; \
                   ++(iterator);                                          \
                   break;                                                 \
               case (int)(QUEX_TYPE_LEXATOM)'\n':                       \
                   (counter)._line_number_at_end   += 1;                  \
                   (counter)._column_number_at_end  = 1;                  \
                   ++(iterator);                                          \
                   break;                                                 \
               default:                                                   \
                   if     ( (*iterator & 0x80) == 0 ) { iterator += 1; } /* 1byte character */ \
                   /* NOT ( (*iterator & 0x40) == 0 ) { iterator += 2; }    2byte character */ \
                   else if( (*iterator & 0x20) == 0 ) { iterator += 2; } /* 3byte character */ \
                   else if( (*iterator & 0x10) == 0 ) { iterator += 3; } /* 3byte character */ \
                   else if( (*iterator & 0x08) == 0 ) { iterator += 4; } /* 4byte character */ \
                   else if( (*iterator & 0x04) == 0 ) { iterator += 5; } /* 5byte character */ \
                   else if( (*iterator & 0x02) == 0 ) { iterator += 6; } /* 6byte character */ \
                   else if( (*iterator & 0x01) == 0 ) { iterator += 7; } /* 7byte character */ \
                   else                               { iterator += 1; } /* default 1       */ \
                   (counter)._column_number_at_end += 1;                  \
                   break;                                                 \
               }
#   elif QUEX_SETTING_CHAR_CODEC == utf16
#       define __QUEX_COUNTER_RULES(counter, iterator) \
               switch( (int)(QUEX_TYPE_LEXATOM)(*iterator) ) {         \
               case (int)(QUEX_TYPE_LEXATOM)'\t':                      \
                   (counter)._column_number_at_end &= (~(size_t)0x3) + 4;\
                   ++(iterator);                            \
                   break;                                   \
               case (int)(QUEX_TYPE_LEXATOM)'\n':         \
                   (counter)._line_number_at_end  += 1;     \
                   (counter)._column_number_at_end  = 1;    \
                   ++(iterator);                            \
                   break;                                   \
               default:                                     \
                   if     ( *iterator < 0xD800 )  { iterator += 1; } /* 1 chunk character */  \
                   else if( *iterator > 0xDBFF )  { iterator += 1; } /* 1 chunk character */  \
                   else                           { iterator += 2; } /* 2 chunk character */  \
                   (counter)._column_number_at_end += 1;    \
                   break;                                   \
               }
#   else
#       define __QUEX_COUNTER_RULES(counter, iterator) \
               switch( (int)(*iterator) ) {                                      \
               case (int)(QUEX_TYPE_LEXATOM)'\t':    \
                   (counter)._column_number_at_end &= (~(size_t)0x3) + 4; break; \
               case (int)(QUEX_TYPE_LEXATOM)'\n':    \
                   (counter)._line_number_at_end   += 1;                         \
                   (counter)._column_number_at_end  = 1;                  break; \
               default:                                \
                   (counter)._column_number_at_end += 1;                  break; \
               }                                                                 \
               ++(iterator);
#   endif

#endif

/* Special Case MinGW: At the time of this writing (2009y09m23d) it does 
 * not support 'wchart_t'.                                                */
#if      (defined (__GLIBCPP__) || defined(__GLIBCXX__)) \
    && ! defined  (_GLIBCXX_USE_WCHAR_T)
#   define  QUEX_OPTION_WCHAR_T_DISABLED
#endif
#ifndef     QUEX_OPTION_WCHAR_T_DISABLED
#   define  QUEX_OPTION_WCHAR_T
#endif

/* If you have a different setup, define the macros QUEX_SETTING_WCHAR_CODEC
 * and QUEX_SETTING_CHAR_CODEC before the inclusion of this file.
 *
 * NOTE: '8' stands for UTF8, '16' stands for UTF16, and '32' for UTF32.
 *       Do not add anything around those numbers, otherwise the macros
 *       will not trigger the right mappings.                             */
#if ! defined(QUEX_SETTING_WCHAR_CODEC)
#   if defined(_WIN32) || defined(_WIN64)
       /* Default: Map 'wchar' to 'utf16' */
#      define QUEX_SETTING_WCHAR_CODEC  16
#   else
       /* Default: Map 'wchar' to 'utf32' */
#      define QUEX_SETTING_WCHAR_CODEC  32
#   endif
#endif

/* Default: Map 'char' to 'utf8' */
#if ! defined(QUEX_SETTING_CHAR_CODEC)
#   define    QUEX_SETTING_CHAR_CODEC   utf8
#endif

#if defined (QUEX_OPTION_ASSERTS_EXT) 
#   define __QUEX_IF_ASSERT(X)  X
#else
#   define __QUEX_IF_ASSERT(X)  /* Ignore */
#endif

/* If the user does not define a class declaration epilog, 
 * define it as empty.                                                        */
#ifndef     QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT
#    define QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT
#endif
