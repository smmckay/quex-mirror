/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_$$LEXER_NAME_SPACE$$
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION__$$INCLUDE_GUARD_EXTENSION$$
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_$$LEXER_NAME_SPACE$$

#include "$$LEXER_CONFIG_FILE$$"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    $$LEXER_DERIVED_CLASS_DECL$$
    class  QUEX_TYPE0_ANALYZER;    /* $$LEXER_CLASS_NAME$$ */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/

$$CONVERTER_HELPER$$
#include <quex/code_base/analyzer/headers>

#include "$$TOKEN_ID_DEFINITION_FILE$$"
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
$$QUEX_MODE_ID_DEFINITIONS$$
};

$$MODE_OBJECTS$$

$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/
$$MEMENTO_EXTENSIONS$$
/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

QUEX_NAMESPACE_MAIN_OPEN 

extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG $$LEXER_CLASS_NAME$$ {
public:
#   include <quex/code_base/analyzer/Engine_body>
private:
    $$LEXER_CLASS_NAME$$(const $$LEXER_CLASS_NAME$$&) {}
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_LEXATOM    char_type;

    /*_________________________________________________________________________
     * Constructor:
     *
     * 'from' functions are provided so that explicit constructor calls 
     * can be done without placement ::new or sophisticated C++11 features.  */
    $$LEXER_CLASS_NAME$$()
    { QUEX_NAME(resources_absent_mark)(this); error_code = E_Error_Uninitialized; }

    $$LEXER_CLASS_NAME$$(const char*      Filename, 
    $$___SPACE___$$ QUEX_NAME(Converter)* Converter = 0) 
    { QUEX_NAME(from_file_name)(this, Filename, Converter); }

    $$LEXER_CLASS_NAME$$(QUEX_NAME(ByteLoader)*  byte_loader, 
    $$___SPACE___$$ QUEX_NAME(Converter)*        Converter = 0) 
    { QUEX_NAME(from_ByteLoader)(this, byte_loader, Converter); }

    $$LEXER_CLASS_NAME$$(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
    $$___SPACE___$$ size_t                  BufferMemorySize,
    $$___SPACE___$$ QUEX_TYPE_LEXATOM*      BufferEndOfContentP = 0x0)
    { QUEX_NAME(from_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /* The 'new' helpers.                                                     */
    static $$LEXER_CLASS_NAME$$* from_file_name(const char*           Filename, 
    $$___SPACE___$$                             QUEX_NAME(Converter)* Converter = 0) 
    { return new $$LEXER_CLASS_NAME$$(Filename, Converter); }

    static $$LEXER_CLASS_NAME$$* from_ByteLoader(QUEX_NAME(ByteLoader)*  byte_loader, 
    $$___SPACE___$$                              QUEX_NAME(Converter)*   Converter = 0) 
    { return new $$LEXER_CLASS_NAME$$(byte_loader, Converter); }

    static $$LEXER_CLASS_NAME$$* from_memory(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
    $$___SPACE___$$                          size_t             BufferMemorySize,
    $$___SPACE___$$                          QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
    { return new $$LEXER_CLASS_NAME$$(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~$$LEXER_CLASS_NAME$$()
    { QUEX_NAME(destruct)(this); }

    /*_________________________________________________________________________
     * Reset:
     *                                                                       */
    bool reset()
    { return QUEX_NAME(reset)(this); }
    bool reset(const char*            FileName, 
               QUEX_NAME(Converter)*  Converter = 0)
    { return QUEX_NAME(reset_file_name)(this, FileName, Converter); }

    bool reset(QUEX_NAME(ByteLoader)*  byte_loader, 
               QUEX_NAME(Converter)*   Converter = 0)
    { return QUEX_NAME(reset_ByteLoader)(this, byte_loader, Converter); }

    bool reset(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
               size_t             BufferMemorySize,
               QUEX_TYPE_LEXATOM* BufferEndOfContentP)  
    { return QUEX_NAME(reset_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    void collect_user_memory(QUEX_TYPE_LEXATOM** user_memory_p)
    { return QUEX_NAME(collect_user_memory)(this, user_memory_p); }

#   ifdef QUEX_OPTION_INCLUDE_STACK
    /*_________________________________________________________________________
     * Include:
     *                                                                       */
    bool    include_push(const char*             FileName, 
                         QUEX_NAME(Converter)*   Converter = 0)
            { return QUEX_NAME(include_push_file_name)(this, FileName, Converter); }
    bool    include_push(const char*             InputName, 
                         QUEX_NAME(ByteLoader)*  byte_loader, 
                         QUEX_NAME(Converter)*   Converter)  /* != 0 to avoid ambiguity. */
            { return QUEX_NAME(include_push_ByteLoader)(this, InputName, byte_loader, Converter); }
    bool    include_push(const char*        InputName, 
                         QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                         size_t             BufferMemorySize,
                         QUEX_TYPE_LEXATOM* BufferEndOfContentP)  
            { return QUEX_NAME(include_push_memory)(this, InputName, BufferMemoryBegin, 
                                                    BufferMemorySize, BufferEndOfContentP); }

    bool    include_pop()
            { return QUEX_NAME(include_pop)(this); }
    void    include_stack_delete()
            { QUEX_NAME(include_stack_delete)(this); }
    bool    include_detect_recursion(const char* InputName)
            { return QUEX_NAME(include_detect_recursion)(this, InputName); }
#   endif

    QUEX_TYPE_LEXATOM*    lexeme_start_pointer_get();
    QUEX_TYPE_LEXATOM*    input_pointer_get();
    void                  input_pointer_set(QUEX_TYPE_LEXATOM*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)      */
    bool                  byte_order_reversion()
            { return QUEX_NAME(byte_order_reversion)(this); }
    void                  byte_order_reversion_set(bool Value)
            { return QUEX_NAME(byte_order_reversion_set)(this, Value); }

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                    */
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                         */
    void                receive(QUEX_TYPE_TOKEN**);

    /* A pointer to an object of the token queue/object is used in order to
     * make memory management more flexible.  The token queue/token object is
     * heavily used and it should be possible to put it somewhere in memory
     * with other heavily used data so that the cache can take advantage of
     * data locality.                                                        */
    QUEX_TYPE_TOKEN*  token_p();
    bool              token_queue_is_empty();
    void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
    void              token_queue_swap(QUEX_TYPE_TOKEN** queue, 
                                       size_t*           size); 
#   if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
    void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
    void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
#   endif

    const char* input_name()
    { return QUEX_NAME(input_name)(this); }
    bool        input_name_set(const char* InputName)
    { return QUEX_NAME(input_name_set)(this, InputName); }

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void                  set_mode_brutally(const int ModeId);
    void                  set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //                    
    void                  operator<<(const int ModeId);               
    void                  operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //                    
    void                  pop_mode();
    void                  pop_drop_mode();
    void                  push_mode(QUEX_NAME(Mode)& new_mode);
    //                    
    void                  enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&      map_mode_id_to_mode(const int              ModeID);       
    int                   map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const            { return line_number_at_begin(); }
    size_t      line_number_at_begin() const   { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const     { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)      { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)    { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                  { return counter._indentation_stack.back - counter._indentation_stack.front + 1; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

private:
    void    resources_absent_mark()
    { QUEX_NAME(resources_absent_mark)(this); }
public:
    bool    resources_absent()
    { return QUEX_NAME(resources_absent)(this); }

    void    set_callback_on_buffer_content_change(void (*callback)(const QUEX_TYPE_LEXATOM*, 
                                                                   const QUEX_TYPE_LEXATOM*));

public:
    void    print_this();

private:
    /* (*) All Modes are Friends ___________________________________________________*/
$$MODE_CLASS_FRIENDS$$  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/
$$CLASS_BODY_EXTENSION$$
/* END: ____________________________________________________________________________*/
#undef  self

public:
    // Token sending happens only via 'self_send*(...)' macros
    void   send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }
};

QUEX_NAMESPACE_MAIN_CLOSE

$$CONVERTER_HELPER_I$$
#include <quex/code_base/analyzer/headers.i>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
