/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Dumlyzer and its memento class.
 * (5) Constructor and init core of Dumlyzer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.66.6-pre.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__

#include "Dumlyzer-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Dumlyzer */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#else
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#endif
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS
#define __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS

#include    <quex/code_base/aux-string>
#include    <quex/code_base/analyzer/asserts>

#include    <quex/code_base/definitions>

#include    <quex/code_base/buffer/Buffer>
#include    <quex/code_base/buffer/lexatoms/LexatomLoader>
#include    <quex/code_base/buffer/bytes/ByteLoader>

#include    <quex/code_base/MemoryManager>
#include    <quex/code_base/analyzer/Mode>

#include    <quex/code_base/analyzer/struct/constructor>
//#include    <quex/code_base/analyzer/member/misc>
//#include    <quex/code_base/analyzer/member/navigation>
//#include    <quex/code_base/analyzer/member/mode-handling>
#include    <quex/code_base/analyzer/member/token-receiving>
#include    <quex/code_base/analyzer/member/token-sending>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS */

#include "Dumlyzer-token_ids"
#include "Dumlyzer-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_M) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(M);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER*);

extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG Dumlyzer {
public:

        /*_________________________________________________________________________
         *  Tokens:      
         *                                                                        
         *  Allow public access.
         *
         *  Tokens are placed directly before the buffer. They are one of the most
         *  used variables. The most used variables shall be stored close to each
         *  other, in order to prevent cache misses.                               
         * 
         *  Note, that the token queue is also implemented from higher addresses 
         *  to lower addresses. It is assumed that it is most likely only filled
         *  at the top, and thus the addresses close to the buffer shall be used
         *  more often than the addresses far from it.                            */
        QUEX_TYPE_TOKEN*   token;         
        uint8_t            __memory_token[sizeof(QUEX_TYPE_TOKEN)];

        E_Error            error_code;
        char*              __input_name;
        QUEX_NAME(Buffer)  buffer;

#if     defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
     || defined(QUEX_OPTION_ASSERTS)
        /* When a mode change happens and the user does not 'return' but 'CONTINUE'
         * an error must be logged, since the following characters are still swallowed
         * by the current function and not the new one. For this one needs to return and
         * then continue further.                                                 */
        QUEX_NAME(AnalyzerFunctionP)  DEBUG_analyzer_function_at_entry;
#       endif

        /* Each mode has a dedicated analyzer function.  The function pointer
         * to the currently active mode's function is stored redundantly in 
         * 'current_analyzer_function' to accelerate the access to it.            */
        QUEX_NAME(AnalyzerFunctionP)  current_analyzer_function;
        QUEX_NAME(Mode)*              __current_mode_p; 

        QUEX_NAME(ModeStack)          _mode_stack;

private:
        Dumlyzer() { assert(false); }
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_LEXATOM    char_type;

    Dumlyzer(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
             size_t             BufferMemorySize,
             QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
    { QUEX_NAME(from_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    static Dumlyzer* from_memory(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                                           size_t             BufferMemorySize,
                                           QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
    { return new Dumlyzer(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~Dumlyzer()
    { QUEX_NAME(destruct)(this); }

    QUEX_TYPE_LEXATOM*    lexeme_start_pointer_get();
    QUEX_TYPE_LEXATOM*    input_pointer_get();
    void                  input_pointer_set(QUEX_TYPE_LEXATOM*);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                    */
    QUEX_TYPE_TOKEN_ID  receive();

    /* A pointer to an object of the token queue/object is used in order to
     * make memory management more flexible.  The token queue/token object is
     * heavily used and it should be possible to put it somewhere in memory
     * with other heavily used data so that the cache can take advantage of
     * data locality.                                                        */
    QUEX_TYPE_TOKEN*     token_p();

private:
    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER*);

  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self
};

QUEX_INLINE void 
QUEX_NAME(set_mode_brutally)(QUEX_TYPE_ANALYZER* me, QUEX_NAME(Mode)* ModeP) 
{ 
    me->__current_mode_p          = ModeP;
    me->current_analyzer_function = ModeP->analyzer_function; 
}

QUEX_INLINE void
QUEX_NAME(set_mode_brutally_by_id)(QUEX_TYPE_ANALYZER* me, const int ModeID)
{ 
    QUEX_NAME(set_mode_brutally)(me, QUEX_NAME(mode_db)[ModeID]); 
}

QUEX_NAMESPACE_MAIN_CLOSE

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer.i"
#else
#   include "quex/code_base/converter_helper/from-unicode-buffer.i"
#endif

#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS_I
#define __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS_I

#if ! defined(__QUEX_INCLUDE_INDICATOR__ANALYZER__CONFIGURATION)
#   error "No configuration header included before this header."
#endif

#include    <quex/code_base/aux-string.i>

#include    <quex/code_base/analyzer/asserts.i>
#include    <quex/code_base/buffer/asserts.i>

/* Token sending happens only via macros, for flexibility. */
#include    <quex/code_base/analyzer/member/token-receiving.i>
//#include    <quex/code_base/analyzer/member/mode-handling.i>
//#include    <quex/code_base/analyzer/member/misc.i>
//#include    <quex/code_base/analyzer/member/navigation.i>
#include    <quex/code_base/analyzer/struct/constructor.i>

#include    <quex/code_base/analyzer/Mode.i>

#include    <quex/code_base/buffer/Buffer.i>
#include    <quex/code_base/buffer/lexatoms/LexatomLoader.i>
#include    <quex/code_base/buffer/bytes/ByteLoader>

#if defined(__QUEX_OPTION_CONVERTER)
#   include <quex/code_base/buffer/lexatoms/LexatomLoader_Converter.i>
#endif


#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__HEADERS_I */

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER

QUEX_NAMESPACE_MAIN_OPEN

bool
QUEX_NAME(user_constructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_M)] == &QUEX_NAME(M));


#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_destructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

QUEX_NAMESPACE_MAIN_CLOSE


bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER


QUEX_NAMESPACE_TOKEN_OPEN

const char*
QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID)
{ return ""; }

QUEX_NAMESPACE_TOKEN_CLOSE
bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
