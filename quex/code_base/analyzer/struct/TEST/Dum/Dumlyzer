/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Dumlyzer and its memento class.
 * (5) Constructor and init core of Dumlyzer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.66.6-pre.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__

#include "Dumlyzer-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Dumlyzer */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#include    <quex/code_base/analyzer/asserts>

#include    <quex/code_base/definitions>

#include    <quex/code_base/buffer/Buffer>
#include    <quex/code_base/buffer/lexatoms/LexatomLoader>
#include    <quex/code_base/buffer/bytes/ByteLoader>

#include    <quex/code_base/MemoryManager>
#include    <quex/code_base/analyzer/Mode>

#include    <quex/code_base/analyzer/struct/constructor>


#include "Dumlyzer-token_ids"
#include "Dumlyzer-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_M) = 0
};

        extern QUEX_NAME(Mode)  QUEX_NAME(M);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER*);

extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG Dumlyzer {
private:
    Dumlyzer() { assert(false); }
public:

    QUEX_TYPE_TOKEN*              token;         
    uint8_t                       __memory_token[sizeof(QUEX_TYPE_TOKEN)];

    E_Error                       error_code;
    char*                         __input_name;
    QUEX_NAME(Buffer)             buffer;

    QUEX_NAME(AnalyzerFunctionP)  current_analyzer_function;
    QUEX_NAME(Mode)*              __current_mode_p; 

    QUEX_NAME(ModeStack)          _mode_stack;

    Dumlyzer(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
             size_t             BufferMemorySize,
             QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
    { QUEX_NAME(from_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    static Dumlyzer* from_memory(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                                           size_t             BufferMemorySize,
                                           QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
    { return new Dumlyzer(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~Dumlyzer()
    { QUEX_NAME(destruct)(this); }

private:
    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER*);

  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self
};

QUEX_INLINE void 
QUEX_NAME(set_mode_brutally)(QUEX_TYPE_ANALYZER* me, QUEX_NAME(Mode)* ModeP) 
{ 
    me->__current_mode_p          = ModeP;
    me->current_analyzer_function = ModeP->analyzer_function; 
}

QUEX_INLINE void
QUEX_NAME(set_mode_brutally_by_id)(QUEX_TYPE_ANALYZER* me, const int ModeID)
{ 
    QUEX_NAME(set_mode_brutally)(me, QUEX_NAME(mode_db)[ModeID]); 
}

QUEX_NAMESPACE_MAIN_CLOSE

#include    <quex/code_base/analyzer/asserts.i>
#include    <quex/code_base/analyzer/struct/constructor.i>
#include    <quex/code_base/analyzer/Mode.i>
#include    <quex/code_base/buffer/Buffer.i>
#include    <quex/code_base/buffer/lexatoms/LexatomLoader.i>
#include    <quex/code_base/buffer/bytes/ByteLoader>

#if defined(__QUEX_OPTION_CONVERTER)
#   include <quex/code_base/buffer/lexatoms/LexatomLoader_Converter.i>
#endif

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER

QUEX_NAMESPACE_MAIN_OPEN

bool
QUEX_NAME(user_constructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_M)] == &QUEX_NAME(M));


#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_destructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

QUEX_NAMESPACE_MAIN_CLOSE


bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER


QUEX_NAMESPACE_TOKEN_OPEN

const char*
QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID)
{ return ""; }

QUEX_NAMESPACE_TOKEN_CLOSE
bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
