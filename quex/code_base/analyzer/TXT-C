/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) $$INC: definitions$$ for default settings.
 * (4) Lexical FSM class $$LEXER_CLASS_NAME$$ and its memento class.
 * (5) Constructor and init core of $$LEXER_CLASS_NAME$$.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex $$QUEX_VERSION$$.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef QUEX_INCLUDE_GUARD__ANALYZER__GENERATED
#define QUEX_INCLUDE_GUARD__ANALYZER__GENERATED

#include <stddef.h>
$$INC: quex/compatibility/stdint.h$$
#include "$$LEXER_CONFIG_FILE$$"

$$INC: definitions$$

QUEX_NAMESPACE_MAIN_OPEN 
struct QUEX_NAME(Engine_tag);
struct QUEX_NAME(Memento_tag);
QUEX_TYPE0_ANALYZER;    /* $$LEXER_CLASS_NAME_SAFE$$ */
typedef void  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE0_ANALYZER*);

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content ___________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */
$$USER_DEFINED_HEADER$$
/* END: _______________________________________________________________________*/

$$INC: declarations$$

#include "$$TOKEN_ID_DEFINITION_FILE$$"
QUEX_NAMESPACE_MAIN_OPEN 
extern const char* QUEX_NAME(map_token_id_to_name)(const QUEX_TYPE_TOKEN_ID TokenID);
QUEX_NAMESPACE_MAIN_CLOSE 
#include "$$TOKEN_CLASS_DEFINITION_FILE$$"

QUEX_NAMESPACE_MAIN_OPEN 

$$MODE_OBJECTS$$

$$MODE_SPECIFIC_ANALYSER_FUNCTIONS$$

typedef bool (*QUEX_NAME(callback_on_token_type))(QUEX_TYPE_TOKEN*);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT QUEX_NAME(Memento_tag) {
    /* In contrary to C++ implementation, constructors and destructors 
     * are called explicitly.                                                 */

    char*                               __input_name;
    QUEX_NAME(Buffer)                   buffer;

    const struct QUEX_NAME(Mode_tag)*   __current_mode_p; 
    QUEX_NAME(AnalyzerFunctionP)        current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS_EXT)
    QUEX_NAME(AnalyzerFunctionP)        DEBUG_analyzer_function_at_entry;
#   endif
    $$<count>       QUEX_NAME(Counter)  counter;$$
    $$<indentation> bool                _indentation_handler_active_f;$$
    struct QUEX_NAME(Memento_tag)*      _parent_memento;

/* START: User's memento extentions __________________________________________*/
$$MEMENTO_EXTENSIONS$$
/* END: ______________________________________________________________________*/
} QUEX_NAME(Memento);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT $$LEXER_CLASS_NAME_SAFE$$_tag {
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    QUEX_NAME(Buffer)               buffer;
    QUEX_NAME(TokenQueue)           _token_queue;  
    QUEX_NAME(ModeStack)            _mode_stack;

    E_Error                         error_code;
    char*                           __input_name;

    const QUEX_NAME(Mode)*          __current_mode_p; 
    /* Shortcut to current mode's analyzer function.                          */
    QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS_EXT)
    /* Backup of analyzer's function pointer => mode change detection.        */
    QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
    $$<count>       QUEX_NAME(Counter) counter;$$
    $$<indentation> bool               _indentation_handler_active_f;$$
    QUEX_NAME(Memento)*                _parent_memento;
    /*__( Reset )_______________________________________________________________
     *                                                                        */
    $$MF: bool reset()$$
    $$MF: bool reset_file_name(const char* FileName, QUEX_NAME_Converter_*  Converter = 0)$$
    $$MF: bool reset_ByteLoader(QUEX_NAME_ByteLoader_*  byte_loader, QUEX_NAME_Converter_*   Converter = 0)$$
    $$MF: bool reset_memory(QUEX_TYPE_LEXATOM* BufferMemoryBegin, size_t BufferMemorySize, QUEX_TYPE_LEXATOM* BufferEndOfContentP)$$

    /*__( Include From and To Substream )_______________________________________
     *                                                                        */
    $$MF: bool include_push_file_name(const char* FileName, QUEX_NAME_Converter_* Converter = 0)$$
    $$MF: bool include_push_ByteLoader(const char* InputName, QUEX_NAME_ByteLoader_*  byte_loader, QUEX_NAME_Converter_*   Converter)$$
    $$MF: bool include_push_memory(const char* InputName, QUEX_TYPE_LEXATOM* BufferMemoryBegin, size_t BufferMemorySize, QUEX_TYPE_LEXATOM* BufferEndOfContentP)$$
    $$MF: bool include_pop()$$
    $$MF: void include_stack_delete()$$
    $$MF: bool include_detect_recursion(const char* InputName)$$

    /*__( Receiving Tokens -- from outside lexer )_____________________________
     *                                                                       */
    $$MF: bool run(QUEX_NAME_callback_on_token_type_ on_token, bool ErrorPrintF)$$
    $$MF: void receive(QUEX_TYPE_TOKEN** token_pp)$$

    /*__( Sending Tokens -- from inside lexer )________________________________
     *                                                                       */
    $$MF: QUEX_TYPE_TOKEN*  token_p()$$

    $$MF: void send(QUEX_TYPE_TOKEN_ID Id)$$
    $$MF: void send_n(QUEX_TYPE_TOKEN_ID Id, size_t RepetitionN)$$
    $$MF: bool send_text(QUEX_TYPE_TOKEN_ID Id, QUEX_TYPE_LEXATOM* BeginP, QUEX_TYPE_LEXATOM* EndP)$$
    $$MF: bool send_string(QUEX_TYPE_TOKEN_ID Id, QUEX_TYPE_LEXATOM* ZeroTerminatedString)$$

    /*__( Mode Handling )______________________________________________________
     *                                                                       */
    $$MF: const QUEX_NAME_Mode_*  mode()$$
    $$MF: void                    set_mode_brutally(const QUEX_NAME_Mode_* Mode)$$
    $$MF: void                    enter_mode(const QUEX_NAME_Mode_* TargetMode)$$

    $$MF: void pop_mode()$$
    $$MF: void pop_drop_mode()$$
    $$MF: void push_mode(QUEX_NAME_Mode_* new_mode)$$

    /*__( Line/Column Counter )________________________________________________
     *                                                                       */
    $$MF: <count-line>   size_t line_number() const$$
    $$MF: <count-line>   size_t line_number_at_begin() const$$
    $$MF: <count-line>   size_t line_number_at_end() const$$
    $$MF: <count-line>   void   line_number_set(size_t Y)$$

    $$MF: <count-column> size_t column_number() const$$
    $$MF: <count-column> size_t column_number_at_begin() const$$
    $$MF: <count-column> size_t column_number_at_end() const$$
    $$MF: <count-column> void   column_number_set(size_t X)$$

    /*__( Indentation )________________________________________________________
     *                                                                       */
    $$MF: <indentation>  size_t  indentation() const$$

    /*__( General Information )________________________________________________
     *                                                                       */
    $$MF: const char*  version()$$
    $$MF: void         print_this()$$
    $$MF: const char*  input_name()$$
    $$MF: bool         input_name_set(const char* InputName)$$

    /*__( Navigation: Tell/Seek )______________________________________________
     *                                                                       */
    $$MF: size_t  tell()$$
    $$MF: void    seek(const size_t CharacterIndex)$$
    $$MF: void    seek_forward(const size_t CharacterN)$$
    $$MF: void    seek_backward(const size_t CharacterN)$$
                
    $$MF: void    undo()$$
    $$MF: void    undo_n(size_t DeltaN_Backward)$$

    /*__( Byte Order Reversion Activation / Deactivation )_____________________
     *                                                                       */
    $$MF: bool byte_order_reversion()$$
    $$MF: void byte_order_reversion_set(bool Value)$$

    /*__( Error Codes )________________________________________________________
     *                                                                       */
    $$MF: void error_code_clear()$$
    $$MF: bool error_code_is_void()$$
    $$MF: void error_code_set_void()$$
    $$MF: void error_code_set_if_first(E_Error ErrorCode)$$

    /*__( Deep Resources )_____________________________________________________
     *                                                                       */
    $$MF: void collect_user_memory(QUEX_TYPE_LEXATOM** user_memory_p)$$
    $$MF: void resources_absent_mark()$$
    $$MF: bool resources_absent()$$

#define self  (*(QUEX_TYPE_ANALYZER*)this)
/* START: User's class body extensions _______________________________________*/
$$CLASS_BODY_EXTENSION$$
/* END: ______________________________________________________________________*/
#undef  self

} $$LEXER_CLASS_NAME_SAFE$$;

$$<C> QUEX_INLINE void QUEX_NAME(member_functions_assign)(QUEX_TYPE_ANALYZER* me);$$

$$EPILOG$$

$$INC: implementations-inline.i$$

#endif /* QUEX_INCLUDE_GUARD__ANALYZER__GENERATED */
