token_type {
   header {
#include <iostream>
#include <string>

$INCLUDE_CONVERTER_DECLARATION
#include <quex/code_base/lexeme>
   }
   standard {
        id            : uint32_t;
        line_number   : size_t;
        column_number : size_t;
   }
   distinct {
       text   :  std::basic_string<QUEX_TYPE_LEXATOM>;
       number :  size_t;
   }

   inheritable;

   copy {
        self._id    = Other._id;
        self.text   = Other.text;
        self.number = Other.number;
#       ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
        __QUEX_IF_COUNT_LINES(self._line_n     = Other._line_n);
        __QUEX_IF_COUNT_COLUMNS(self._column_n = Other._column_n);
#       endif
   }

   body {
        typedef std::basic_string<QUEX_TYPE_LEXATOM> __string;

        operator 
        const std::string() const
        { return get_string(); }

        const std::string
        get_string() const 
        {
            std::string  tmp;
            tmp  = map_id_to_name(self._id);
#           if ! defined(QUEX_OPTION_LEXEME_CONVERTERS_DISABLED)
            tmp += " '" + QUEX_NAME_TOKEN(lexeme_to_pretty_char)(self.text) + "'";
#           else
            tmp += " '<converters of .text to pretty char disabled>'";
#           endif
            return tmp;
        }
    
   }

   take_text {
#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_LEXATOM* it = 0x0;
            printf("%lX ", (long)__this);
            printf("previous:  '");
            for(it = (QUEX_TYPE_LEXATOM*)self.text.begin(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
            printf("take_text: '");
            for(it = (QUEX_TYPE_LEXATOM*)Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* It cannot be assumed that the lexeme is zero terminated. */
        __quex_assert(End >= Begin);
        self.text.assign(Begin, (size_t)(End-Begin));

#       if 0
        {
            /* Hint for debug: To check take_text change "#if 0" to "#if 1". */
            QUEX_TYPE_LEXATOM* it = 0x0;
            printf("after:     '");
            for(it = (QUEX_TYPE_LEXATOM*)self.text.begin(); *it ; ++it) printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   }

   repetition_set {
       self.number = N;
   }

   repetition_get {
       return self.number;
   }

   footer {
$NAMESPACE_OPEN
inline std::ostream&
operator<<(std::ostream& ostr, const $TOKEN_CLASS& Tok)
{ ostr << Tok.get_string(); return ostr; }
$NAMESPACE_CLOSE

$INCLUDE_CONVERTER_IMPLEMENTATION
#include <quex/code_base/lexeme.i>
   }
}

