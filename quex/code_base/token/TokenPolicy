/* -*- C++ -*- vim: set syntax=cpp: 
 * (C) 2005-2017 Frank-Rene Schaefer
 *
 * NO INCLUDE GUARDS -- THIS FILE MIGHT BE INCLUDED TWICE FOR MULTIPLE
 *                      LEXICAL ANALYZERS
 *
 * NOT: #ifndef  __QUEX_INCLUDE_GUARD__TOKEN__TOKEN_POLICY
 * NOT: #define  __QUEX_INCLUDE_GUARD__TOKEN__TOKEN_POLICY              
 *
 * Instead of an include guard, there is an include indicator 
 *
 *         __QUEX_INCLUDE_INDICATOR__TOKEN_POLICY__
 *
 * If the indicator is defined at the entry of this file, all internally 
 * defined macros are undefined right at the beginning, so they can be 
 * safely redefined.                                                     */
#ifdef __QUEX_INCLUDE_INDICATOR__TOKEN_POLICY__
#    undef self_write_token_p
#    undef __QUEX_STAMP_COLUMN_NUMBER
#    undef __QUEX_STAMP_LINE_NUMBER
#    undef QUEX_TOKEN_POLICY_PREPARE_NEXT
#    undef self_token_get_id
#    undef self_token_set_id
#else
#    define __QUEX_INCLUDE_INDICATOR__TOKEN_POLICY__
#endif
/*_______________________________________________________________________*/

#define self_write_token_p()             (self._token_queue.write_iterator)
#define QUEX_TOKEN_POLICY_PREPARE_NEXT() ++(self._token_queue.write_iterator) 

/* Setting a token value. 
 *  
 *  This may include the stamping of line and/or column numbers. The macros to
 *  do that are empty in case that the stamping is disabled (see the above
 *  definitions). The last element of the subsequent macro provides access to
 *  the current token. This access depends on whether the token policy 'users
 *  token' or a queue policy is used.                                         */
                                    
#define self_token_get_id()                                  \
        (self_write_token_p()->_id)

#define self_token_set_id(ID)                                \
        do {                                                 \
            QUEX_ACTION_TOKEN_STAMP(self_write_token_p());   \
            self_write_token_p()->_id = (ID);                \
        } while(0)

#define self_token_take_text(Begin, End) \
        QUEX_NAME_TOKEN(take_text)(self_write_token_p(), &self, (Begin), (End))

#if defined(QUEX_OPTION_TOKEN_REPETITION_SUPPORT)
#  define self_token_repetition_n_set() \
          QUEX_NAME_TOKEN(repetition_n_set)(self_write_token_p(), RepetitionN); 
#endif

/* Option: QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
 *
 * This option enables the stamping of tokens at the time that they are sent
 * with the current position of the lexeme in terms of line and column
 * numbers. Note, that if line or column numbering is disabled than also
 * the stamping of the corresponding value is disabled. 
 *
 * In the default token class the members '_line_n' and '_column_n' only 
 * exist if the corresponding stamping is active.                            */
#if    defined(QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN) \
    && defined(QUEX_OPTION_LINE_NUMBER_COUNTING)
#       define __QUEX_STAMP_LINE_NUMBER(TOKEN)                  \
               (TOKEN)->_line_n = self.counter._line_number_at_begin;
#else
#       define __QUEX_STAMP_LINE_NUMBER(TOKEN)    /* empty */
#endif

#if    defined(QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN) \
    && defined(QUEX_OPTION_COLUMN_NUMBER_COUNTING)
#       define __QUEX_STAMP_COLUMN_NUMBER(TOKEN)                \
               (TOKEN)->_column_n = self.counter._column_number_at_begin;
#else
#       define __QUEX_STAMP_COLUMN_NUMBER(TOKEN)  /* empty */
#endif

/* We do not define QUEX_ACTION_TOKEN_STAMP in 'configuration/derived' since
 * the derived configuration is included before the user's header.  The user's
 * header requires the configuration parameters.                             */
#if ! defined(QUEX_ACTION_TOKEN_STAMP) 
#     define  QUEX_ACTION_TOKEN_STAMP(TOKEN_P)   \
              __QUEX_STAMP_LINE_NUMBER(TOKEN_P)  \
              __QUEX_STAMP_COLUMN_NUMBER(TOKEN_P) 
#endif

