/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$

#include <cstddef>
$$INC: compatibility/stdint.h$$
$$HELPER_DEFINITIONS$$
$$INC: definitions$$
$$INC: asserts$$
$$INC: MemoryManager$$
$$INC: lexeme_base$$

$$HEADER$$
 
QUEX_NAMESPACE_TOKEN_OPEN

class $TOKEN_CLASS;

inline void    QUEX_NAME_TOKEN(construct)($TOKEN_CLASS* __this);
inline void    QUEX_NAME_TOKEN(destruct)($TOKEN_CLASS* __this);
inline void    QUEX_NAME_TOKEN(copy)($TOKEN_CLASS*       me, 
                                     const $TOKEN_CLASS* That);
#ifdef QUEX_OPTION_TOKEN_TAKE_TEXT_SUPPORT
inline bool    QUEX_NAME_TOKEN(take_text)($TOKEN_CLASS*             __this, 
                                          const QUEX_TYPE_LEXATOM*  Begin, 
                                          const QUEX_TYPE_LEXATOM*  End);
#endif

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
inline size_t  QUEX_NAME_TOKEN(repetition_n_get)($TOKEN_CLASS* __this);
inline void    QUEX_NAME_TOKEN(repetition_n_set)($TOKEN_CLASS* __this, 
                                                 size_t        N);
#endif 

inline const char*  
               QUEX_NAME_TOKEN(map_id_to_name)(const QUEX_TYPE_TOKEN_ID);


class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG $TOKEN_CLASS {
public:
    $TOKEN_CLASS();
    $TOKEN_CLASS(const $TOKEN_CLASS& That);
    /* operator=(..): USE WITH CAUTION--POSSIBLE MAJOR PERFORMANCE DECREASE! 
     *                BETTER USE __copy(That)                                */
    $TOKEN_CLASS& operator=(const $TOKEN_CLASS& That) 
    { QUEX_NAME_TOKEN(copy)(this, &That); return *this; }
    $$VIRTUAL_DESTRUCTOR$$~$TOKEN_CLASS();

$$DISTINCT_MEMBERS$$
$$UNION_MEMBERS$$
public:
$$SETTERS_GETTERS$$
    void set(const QUEX_TYPE_TOKEN_ID ID) { id = ID; }
$$QUICK_SETTERS$$

    public:
        /* _line_n, _column_n, and id are public, so that the token policy 
         * can access it. making it private would imply complications for 
         * user customized token classes. The token policies should be the
         * same for C and Cpp.                                               */
        QUEX_TYPE_TOKEN_ID    id;
        QUEX_TYPE_TOKEN_ID    type_id() const                             { return id; }
        const char*           map_id_to_name(QUEX_TYPE_TOKEN_ID ID) const { return QUEX_NAME_TOKEN(map_id_to_name)(ID); }
        const std::string     type_id_name() const                        { return map_id_to_name(id); }

#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_COUNTER_LINE
    public:
        QUEX_TYPE_TOKEN_LINE_N    _line_n;
        QUEX_TYPE_TOKEN_LINE_N    line_number() const                                 { return _line_n; }
        void                      set_line_number(const QUEX_TYPE_TOKEN_LINE_N Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COUNTER_COLUMN
    public:
        QUEX_TYPE_TOKEN_COLUMN_N  _column_n;
        QUEX_TYPE_TOKEN_COLUMN_N  column_number() const                                   { return _column_n; }
        void                      set_column_number(const QUEX_TYPE_TOKEN_COLUMN_N Value) { _column_n = Value; }
#       endif
#   endif
    public:
#   define self (*this)
$$BODY$$
#   undef  self

    private:
        friend void QUEX_NAME_TOKEN(copy)($TOKEN_CLASS*       __this, 
                                          const $TOKEN_CLASS* That);
        friend bool QUEX_NAME_TOKEN(take_text)($TOKEN_CLASS*             __this, 
                                               const QUEX_TYPE_LEXATOM*  Begin, 
                                               const QUEX_TYPE_LEXATOM*  End);
};

QUEX_NAMESPACE_TOKEN_CLOSE

$$FOOTER$$

$$LEXEME_NULL_DECLARATION$$

#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED__$$INCLUDE_GUARD_EXTENSION$$ */
