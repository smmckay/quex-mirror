QUEX_INLINE void
QUEX_NAME(lexeme_nnzt_to_$$DRAIN_ENCODING$$)(const QUEX_TYPE_LEXATOM**      source_pp, 
                                            const QUEX_TYPE_LEXATOM*        SourceEnd, 
                                            $$DRAIN_CODE_UNIT_TYPE$$**      drain_pp,  
                                            const $$DRAIN_CODE_UNIT_TYPE$$* DrainEnd)
/* Convert a lexeme that is *not necessarily zero terminated* (nnzt), adapt the 
 * pointer to begin of source and begin of drain for quick iteration over 
 * larger segments.                                                           */
{
    const QUEX_TYPE_LEXATOM*  source_iterator; 
    $$DRAIN_CODE_UNIT_TYPE$$* drain_iterator;
    const ptrdiff_t           TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$; /* UF32=1, UTF16=2, utf8=... */

    __quex_assert(source_pp != 0x0);
    __quex_assert(*source_pp != 0x0);
    __quex_assert(drain_pp != 0x0);
    __quex_assert(*drain_pp != 0x0);

    drain_iterator  = *drain_pp;
    for(source_iterator=*source_pp; source_iterator != SourceEnd; ) { 
        if     ( source_iterator == SourceEnd ) break;
        else if( DrainEnd - drain_iterator < TargetMaxCodeUnitN ) break;
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_iterator, &drain_iterator);
        __quex_assert(source_iterator >  *source_pp);
        __quex_assert(source_iterator <= SourceEnd);
    }

    *drain_pp  = drain_iterator;
    *source_pp = source_iterator;
}

QUEX_INLINE $$DRAIN_CODE_UNIT_TYPE$$*
QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$)(const QUEX_TYPE_LEXATOM*         SourceBegin, 
                                        $$DRAIN_CODE_UNIT_TYPE$$*        drain_p,  
                                        const $$DRAIN_CODE_UNIT_TYPE$$*  DrainEnd)
/* Convert a zero-terminated lexeme. Adapt the drain pointer for quicker
 * iteration over write buffer.                                               */
{
    const QUEX_TYPE_LEXATOM*  source_iterator; 
    $$DRAIN_CODE_UNIT_TYPE$$* drain_iterator;
    const ptrdiff_t           TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$; /* UF32=1, UTF16=2, utf8=... */

    __quex_assert(SourceBegin != 0x0);
    __quex_assert(drain_p != 0x0);

    drain_iterator  = drain_p;
    source_iterator = SourceBegin;

    for(source_iterator=SourceBegin; (QUEX_TYPE_LEXATOM)0 != *source_iterator; ) { 
        if( DrainEnd - drain_iterator < TargetMaxCodeUnitN ) break;
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_iterator, &drain_iterator);
        __quex_assert(source_iterator > SourceBegin);
    }

    return drain_iterator;
}

#if ! defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE std::basic_string<$$DRAIN_CODE_UNIT_TYPE$$>
QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$)(const std::basic_string<QUEX_TYPE_LEXATOM>& Source)
{
    /* Avoiding the mess with 'c_str()' and 'begin()' in 'std::string()'
     * => copy string to a temporary array.                                   */
    QUEX_TYPE_LEXATOM*                 source = (QUEX_TYPE_LEXATOM*)
                                                QUEXED(MemoryManager_allocate)(
                                                sizeof(QUEX_TYPE_LEXATOM) * (Source.length() + 1),
                                                E_MemoryObjectType_TEXT);
    const QUEX_TYPE_LEXATOM*           source_iterator;
    const QUEX_TYPE_LEXATOM*           SourceEnd = &source[Source.length()];
    const ptrdiff_t                    TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$;
    $$DRAIN_CODE_UNIT_TYPE$$           drain[TargetMaxCodeUnitN];
    $$DRAIN_CODE_UNIT_TYPE$$*          drain_iterator  = 0;
    std::basic_string<$$DRAIN_CODE_UNIT_TYPE$$>  result;

    if( ! Source.copy(&source[0], Source.length()) ) {
        QUEXED(MemoryManager_free)(source, E_MemoryObjectType_TEXT);
        return result;
    }
    /* .copy() does not append a terminating zero ...
     * and it is not to be copied.                                            */

    for(source_iterator = &source[0]; source_iterator != SourceEnd; ) {
        drain_iterator = drain;
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_iterator, &drain_iterator);
        __quex_assert(source_iterator >  &source[0]);
        __quex_assert(source_iterator <= SourceEnd);
        result.append(($$DRAIN_CODE_UNIT_TYPE$$*)drain, (size_t)(drain_iterator - drain));
    }

    QUEXED(MemoryManager_free)(source, E_MemoryObjectType_TEXT);
    return result;
}
#endif

