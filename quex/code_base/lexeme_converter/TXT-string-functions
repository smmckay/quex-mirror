QUEX_INLINE void
QUEX_NAME(lexeme_nnzt_to_$$DRAIN_ENCODING$$)(const QUEX_TYPE_LEXATOM**      source_pp, 
                                            const QUEX_TYPE_LEXATOM*        SourceEnd, 
                                            $$DRAIN_CODE_UNIT_TYPE$$**      drain_pp,  
                                            const $$DRAIN_CODE_UNIT_TYPE$$* DrainEnd)
/* Convert a lexeme that is *not necessarily zero terminated* (nnzt), adapt the 
 * pointer to begin of source and begin of drain for quick iteration over 
 * larger segments.                                                           */
{
    const QUEX_TYPE_LEXATOM*  source_iterator; 
    $$DRAIN_CODE_UNIT_TYPE$$* drain_it;
    const ptrdiff_t           TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$; /* UF32=1, UTF16=2, utf8=... */

    __quex_assert(source_pp != 0x0);
    __quex_assert(*source_pp != 0x0);
    __quex_assert(drain_pp != 0x0);
    __quex_assert(*drain_pp != 0x0);

    drain_it  = *drain_pp;
    for(source_iterator=*source_pp; source_iterator != SourceEnd; ) { 
        if     ( source_iterator == SourceEnd ) break;
        else if( DrainEnd - drain_it < TargetMaxCodeUnitN ) break;
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_iterator, &drain_it);
        __quex_assert(source_iterator >  *source_pp);
        __quex_assert(source_iterator <= SourceEnd);
    }

    *drain_pp  = drain_it;
    *source_pp = source_iterator;
}

QUEX_INLINE $$DRAIN_CODE_UNIT_TYPE$$*
QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$)(const QUEX_TYPE_LEXATOM*         SourceBegin, 
                                        $$DRAIN_CODE_UNIT_TYPE$$*        drain_p,  
                                        const $$DRAIN_CODE_UNIT_TYPE$$*  DrainEnd)
/* Convert a zero-terminated lexeme. Adapt the drain pointer for quicker
 * iteration over write buffer.                                               */
{
    const QUEX_TYPE_LEXATOM*  source_iterator; 
    $$DRAIN_CODE_UNIT_TYPE$$* drain_it;
    const ptrdiff_t           TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$; /* UF32=1, UTF16=2, utf8=... */

    __quex_assert(SourceBegin != 0x0);
    __quex_assert(drain_p != 0x0);

    drain_it  = drain_p;
    source_iterator = SourceBegin;

    for(source_iterator=SourceBegin; (QUEX_TYPE_LEXATOM)0 != *source_iterator; ) { 
        if( DrainEnd - drain_it < TargetMaxCodeUnitN ) break;
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_iterator, &drain_it);
        __quex_assert(source_iterator > SourceBegin);
    }

    return drain_it;
}

#if ! defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE std::basic_string<$$DRAIN_CODE_UNIT_TYPE$$>
QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$)(const std::basic_string<QUEX_TYPE_LEXATOM>& Source)
{
    /* Avoiding the mess with 'c_str()' and 'begin()' in 'std::string()'
     * => copy string to a temporary array.                                   */
    const ptrdiff_t            TargetMaxCodeUnitN = $$DRAIN_ENCODING_MAX_CODE_UNIT_N$$;
    $$DRAIN_CODE_UNIT_TYPE$$   drain[TargetMaxCodeUnitN];
    $$DRAIN_CODE_UNIT_TYPE$$*  drain_it  = 0;
    std::basic_string<$$DRAIN_CODE_UNIT_TYPE$$>  result;
    const QUEX_TYPE_LEXATOM*         source_p;

    for(std::basic_string<QUEX_TYPE_LEXATOM>::const_iterator source_it = Source.begin(); 
        source_it != Source.end(); ++source_it) {
        drain_it = drain;
        source_p = &(*source_it);
        QUEX_NAME(lexeme_to_$$DRAIN_ENCODING$$_character)(&source_p, &drain_it);
        result.append(($$DRAIN_CODE_UNIT_TYPE$$*)drain, (size_t)(drain_it - drain));
    }

    return result;
}
#endif

