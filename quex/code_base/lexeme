/* -*- C++ -*- vim:set syntax=cpp: 
 * (C) 2010-2017 Frank-Rene Schaefer    
 * ABSOLUTELY NO WARRANTY                                                     */
#ifndef __QUEX_INCLUDE_GUARD__LEXEME
#define __QUEX_INCLUDE_GUARD__LEXEME

#ifndef    QUEX_NAMESPACE_TOKEN_OPEN
#   error "QUEX_NAMESPACE_TOKEN_OPEN definition missing!"
#endif
#ifndef    QUEX_NAMESPACE_TOKEN_CLOSE
#   error "QUEX_NAMESPACE_TOKEN_CLOSE definition missing!"
#endif
#ifndef    QUEX_NAME_TOKEN
#   error "QUEX_NAME_TOKEN definition missing!"
#endif
#ifndef    QUEX_TYPE_LEXATOM
#   error "QUEX_TYPE_LEXATOM definition missing!"
#endif

#include <quex/code_base/definitions>

QUEX_NAMESPACE_TOKEN_OPEN

QUEX_INLINE size_t 
QUEX_NAME_TOKEN(lexeme_length)(const QUEX_TYPE_LEXATOM* Str);


QUEX_INLINE size_t 
QUEX_NAME_TOKEN(lexeme_compare)(const QUEX_TYPE_LEXATOM* it0, 
                                const QUEX_TYPE_LEXATOM* it1);

/* If QUEX_TYPE_LEXATOM is chosen inappropriately with respect to the
 * character encoding ('wchar_t' carrying 'utf8')
 * => Lexeme helper functions may cause trouble.  
 * => Disable below functions with compile option:
 *
 *                 -DQUEX_OPTION_LEXEME_CONVERTERS_DISABLED                          
 *                                                                            */
#if      defined(QUEX_OPTION_LEXEME_CONVERTERS) \
    && ! defined(QUEX_OPTION_LEXEME_CONVERTERS_DISABLED)
QUEX_INLINE void
QUEX_NAME_TOKEN(lexeme_to_utf8)(const QUEX_TYPE_LEXATOM** source_p, 
                                const QUEX_TYPE_LEXATOM*  SourceEnd,
                                uint8_t**                 drain_p,  
                                const uint8_t*            DrainEnd);

QUEX_INLINE void
QUEX_NAME_TOKEN(lexeme_to_utf16)(const QUEX_TYPE_LEXATOM** source_p, 
                                 const QUEX_TYPE_LEXATOM*  SourceEnd,
                                 uint16_t**                drain_p,  
                                 const uint16_t*           DrainEnd);

QUEX_INLINE void
QUEX_NAME_TOKEN(lexeme_to_utf32)(const QUEX_TYPE_LEXATOM** source_p, 
                                 const QUEX_TYPE_LEXATOM*  SourceEnd,
                                 uint32_t**                drain_p,  
                                 const uint32_t*           DrainEnd);

QUEX_INLINE void
QUEX_NAME_TOKEN(lexeme_to_char)(const QUEX_TYPE_LEXATOM** source_p, 
                                const QUEX_TYPE_LEXATOM*  SourceEnd,
                                char**                    drain_p,  
                                const char*               DrainEnd);

QUEX_INLINE const char* 
QUEX_NAME_TOKEN(lexeme_to_pretty_char)(const QUEX_TYPE_LEXATOM* Lexeme, 
                                       char*                    buffer, 
                                       size_t                   BufferSize); 

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE const std::string 
QUEX_NAME_TOKEN(lexeme_to_pretty_char)(const std::basic_string<QUEX_TYPE_LEXATOM>& Text);
#endif

#if ! defined(__QUEX_OPTION_WCHAR_T_DISABLED)
QUEX_INLINE void
QUEX_NAME_TOKEN(lexeme_to_wchar)(const QUEX_TYPE_LEXATOM** source_p, 
                                 const QUEX_TYPE_LEXATOM*  SourceEnd,
                                 wchar_t**                 drain_p,  
                                 const wchar_t*            DrainEnd);

#endif
#endif /* ! defined(QUEX_OPTION_LEXEME_CONVERTERS_DISABLED) */

QUEX_NAMESPACE_TOKEN_CLOSE

#endif /* __QUEX_INCLUDE_GUARD__LEXEME */
