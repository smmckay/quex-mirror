/* -*- C++ -*-   vim: set syntax=cpp:
* CONTENT:
*
* (1) Includes for required standard headers.
* (2) Definitions of options and settings for the particular application.
* (3) #include "test_environment/lib/definitions"
* (4) Lexical FSM class TestAnalyzer and its memento class.
* (5) Constructor and init core of TestAnalyzer.
* (6) Memento pack and unpack functions.
*
* File content generated by Quex 0.68.2.
*
* (C) 2005-2012 Frank-Rene Schaefer
* ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED______TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED______TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
/* In case that multiple lexical analyzers are used the same header
* files are compiled with a different setting of the macros. The
* undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#include "test_environment/lib/include-guard-undef"
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION______TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___

#include <cstddef>
#include "test_environment/lib/compatibility/stdint.h"
#include "test_environment/TestAnalyzer-configuration"

#include "test_environment/lib/definitions"

QUEX_NAMESPACE_MAIN_OPEN
struct QUEX_NAME(Engine_tag);
struct QUEX_NAME(Memento_tag);

class  QUEX_TYPE0_ANALYZER;    /* TestAnalyzer */
typedef void  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
* can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
class QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content ___________________________________________
*        Must come before token class definition, since the token class
*        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#include "test_environment/lib/analyzer/headers"

#include "test_environment/TestAnalyzer-token_ids"
#include "test_environment/TestAnalyzer-token"

QUEX_NAMESPACE_MAIN_OPEN

extern QUEX_NAME(Mode)  QUEX_NAME(M);
extern QUEX_NAME(Mode)  QUEX_NAME(M2);


extern  void QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
extern  void QUEX_NAME(M_on_buffer_before_change)(void* aux);
extern  void QUEX_NAME(M_on_buffer_overflow)(void* aux);
extern  void QUEX_NAME(M_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
extern  void QUEX_NAME(M_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void QUEX_NAME(M_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif
extern  void QUEX_NAME(M2_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
extern  void QUEX_NAME(M2_on_buffer_before_change)(void* aux);
extern  void QUEX_NAME(M2_on_buffer_overflow)(void* aux);
extern  void QUEX_NAME(M2_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
extern  void QUEX_NAME(M2_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void QUEX_NAME(M2_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif


typedef bool (*QUEX_NAME(callback_on_token_type))(QUEX_TYPE_TOKEN*);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG QUEX_NAME(Memento_tag) {
/* __( Data Members )_______________________________________________________
*                                                                        */
char*                           __input_name;
QUEX_NAME(Buffer)               buffer;

const struct QUEX_NAME(Mode_tag)* __current_mode_p;
QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct QUEX_NAME(Memento_tag)*  _parent_memento;
/* __( END: Data Members )________________________________________________*/

QUEX_NAME(Memento_tag)()  {} /* Con- and Destruction necessary to trigger */
~QUEX_NAME(Memento_tag)() {} /* con- and destruction of user members.     */

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/
} QUEX_NAME(Memento);

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer {
public:
/* __( Data Members )_______________________________________________________
*                                                                        */
QUEX_NAME(Buffer)               buffer;
QUEX_NAME(TokenQueue)           _token_queue;
QUEX_NAME(ModeStack)            _mode_stack;

E_Error                         error_code;
char*                           __input_name;

const QUEX_NAME(Mode)*          __current_mode_p;
/* Shortcut to current mode's analyzer function.                          */
QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
/* Backup of analyzer's function pointer => mode change detection.        */
QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct QUEX_NAME(Memento_tag)*  _parent_memento;

public:
typedef QUEX_TYPE_TOKEN      token_type;
typedef TestAnalyzer_token_id_t   token_id_type;
typedef TestAnalyzer_lexatom_t    char_type;

/*__( Constructors )________________________________________________________
*                                                                        */
TestAnalyzer()
{ QUEX_NAME(MF_resources_absent_mark)(this); error_code = E_Error_Uninitialized; }

TestAnalyzer(const char*      Filename,
QUEX_NAME(Converter)* Converter = 0)
{ QUEX_NAME(from_file_name)(this, Filename, Converter); }

TestAnalyzer(QUEX_NAME(ByteLoader)*  byte_loader,
QUEX_NAME(Converter)*        Converter = 0)
{ QUEX_NAME(from_ByteLoader)(this, byte_loader, Converter); }

TestAnalyzer(TestAnalyzer_lexatom_t* BufferMemoryBegin,
size_t                  BufferMemorySize,
TestAnalyzer_lexatom_t*      BufferEndOfContentP = 0x0)
{ QUEX_NAME(from_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

/* Named placement-new functions.                                         */
static TestAnalyzer* from_file_name(const char*           Filename,
QUEX_NAME(Converter)* Converter = 0)
{ return new TestAnalyzer(Filename, Converter); }

static TestAnalyzer* from_ByteLoader(QUEX_NAME(ByteLoader)*  byte_loader,
QUEX_NAME(Converter)*   Converter = 0)
{ return new TestAnalyzer(byte_loader, Converter); }

static TestAnalyzer* from_memory(TestAnalyzer_lexatom_t* BufferMemoryBegin,
size_t             BufferMemorySize,
TestAnalyzer_lexatom_t* BufferEndOfContentP = 0x0)
{ return new TestAnalyzer(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

virtual ~TestAnalyzer()
{ QUEX_NAME(destruct)(this); }
public:
/*__( Reset )_______________________________________________________________
*                                                                        */
bool reset() { return QUEX_NAME(MF_reset)(this); }
bool reset_file_name(const char* FileName, QUEX_NAME(Converter)* Converter = 0) { return QUEX_NAME(MF_reset_file_name)(this, FileName, Converter); }
bool reset_ByteLoader(QUEX_NAME(ByteLoader)* byte_loader, QUEX_NAME(Converter)* Converter = 0) { return QUEX_NAME(MF_reset_ByteLoader)(this, byte_loader, Converter); }
bool reset_memory(TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP) { return QUEX_NAME(MF_reset_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

/*__( Include From and To Substream )_______________________________________
*                                                                        */
bool include_push_file_name(const char* FileName, QUEX_NAME(Converter)* Converter = 0) { return QUEX_NAME(MF_include_push_file_name)(this, FileName, Converter); }
bool include_push_ByteLoader(const char* InputName, QUEX_NAME(ByteLoader)* byte_loader, QUEX_NAME(Converter)* Converter) { return QUEX_NAME(MF_include_push_ByteLoader)(this, InputName, byte_loader, Converter); }
bool include_push_memory(const char* InputName, TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP) { return QUEX_NAME(MF_include_push_memory)(this, InputName, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }
bool include_pop() { return QUEX_NAME(MF_include_pop)(this); }
void include_stack_delete() { QUEX_NAME(MF_include_stack_delete)(this); }
bool include_detect_recursion(const char* InputName) { return QUEX_NAME(MF_include_detect_recursion)(this, InputName); }

/*__( Receiving Tokens -- from outside lexer )_____________________________
*                                                                       */
bool run(QUEX_NAME(callback_on_token_type) on_token, bool ErrorPrintF) { return QUEX_NAME(MF_run)(this, on_token, ErrorPrintF); }
void receive(QUEX_TYPE_TOKEN** token_pp) { QUEX_NAME(MF_receive)(this, token_pp); }

/*__( Sending Tokens -- from inside lexer )________________________________
*                                                                       */
QUEX_TYPE_TOKEN* token_p() { return QUEX_NAME(MF_token_p)(this); }

void send(TestAnalyzer_token_id_t Id) { QUEX_NAME(MF_send)(this, Id); }
void send_n(TestAnalyzer_token_id_t Id, size_t RepetitionN) { QUEX_NAME(MF_send_n)(this, Id, RepetitionN); }
bool send_text(TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* BeginP, TestAnalyzer_lexatom_t* EndP) { return QUEX_NAME(MF_send_text)(this, Id, BeginP, EndP); }
bool send_string(TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* ZeroTerminatedString) { return QUEX_NAME(MF_send_string)(this, Id, ZeroTerminatedString); }

/*__( Mode Handling )______________________________________________________
*                                                                       */
const QUEX_NAME(Mode)* mode() { return QUEX_NAME(MF_mode)(this); }
void set_mode_brutally(const QUEX_NAME(Mode)* Mode) { QUEX_NAME(MF_set_mode_brutally)(this, Mode); }
void enter_mode(const QUEX_NAME(Mode)* TargetMode) { QUEX_NAME(MF_enter_mode)(this, TargetMode); }

void pop_mode() { QUEX_NAME(MF_pop_mode)(this); }
void pop_drop_mode() { QUEX_NAME(MF_pop_drop_mode)(this); }
void push_mode(QUEX_NAME(Mode)* new_mode) { QUEX_NAME(MF_push_mode)(this, new_mode); }

/*__( Line/Column Counter )________________________________________________
*                                                                       */
size_t line_number() { return QUEX_NAME(MF_line_number)(this); }
size_t line_number_at_begin() { return QUEX_NAME(MF_line_number_at_begin)(this); }
size_t line_number_at_end() { return QUEX_NAME(MF_line_number_at_end)(this); }
void line_number_set(size_t Y) { QUEX_NAME(MF_line_number_set)(this, Y); }

size_t column_number() { return QUEX_NAME(MF_column_number)(this); }
size_t column_number_at_begin() { return QUEX_NAME(MF_column_number_at_begin)(this); }
size_t column_number_at_end() { return QUEX_NAME(MF_column_number_at_end)(this); }
void column_number_set(size_t X) { QUEX_NAME(MF_column_number_set)(this, X); }

/*__( Indentation )________________________________________________________
*                                                                       */


public:
/*__( General Information )________________________________________________
*                                                                       */
const char* version() { return QUEX_NAME(MF_version)(this); }
void print_this() { QUEX_NAME(MF_print_this)(this); }
const char* input_name() { return QUEX_NAME(MF_input_name)(this); }
bool input_name_set(const char* InputName) { return QUEX_NAME(MF_input_name_set)(this, InputName); }

/*__( Navigation: Tell/Seek )______________________________________________
*                                                                       */
size_t tell() { return QUEX_NAME(MF_tell)(this); }
void seek(const size_t CharacterIndex) { QUEX_NAME(MF_seek)(this, CharacterIndex); }
void seek_forward(const size_t CharacterN) { QUEX_NAME(MF_seek_forward)(this, CharacterN); }
void seek_backward(const size_t CharacterN) { QUEX_NAME(MF_seek_backward)(this, CharacterN); }

void undo() { QUEX_NAME(MF_undo)(this); }
void undo_n(size_t DeltaN_Backward) { QUEX_NAME(MF_undo_n)(this, DeltaN_Backward); }

/*__( Byte Order Reversion Activation / Deactivation )_____________________
*                                                                       */
bool byte_order_reversion() { return QUEX_NAME(MF_byte_order_reversion)(this); }
void byte_order_reversion_set(bool Value) { QUEX_NAME(MF_byte_order_reversion_set)(this, Value); }

/*__( Error Codes )________________________________________________________
*                                                                       */
void error_code_clear() { QUEX_NAME(MF_error_code_clear)(this); }
bool error_code_is_void() { return QUEX_NAME(MF_error_code_is_void)(this); }
void error_code_set_void() { QUEX_NAME(MF_error_code_set_void)(this); }
void error_code_set_if_first(E_Error ErrorCode) { QUEX_NAME(MF_error_code_set_if_first)(this, ErrorCode); }

/*__( Deep Resources )_____________________________________________________
*                                                                       */
void collect_user_memory(TestAnalyzer_lexatom_t** user_memory_p) { QUEX_NAME(MF_collect_user_memory)(this, user_memory_p); }
void resources_absent_mark() { QUEX_NAME(MF_resources_absent_mark)(this); }
bool resources_absent() { return QUEX_NAME(MF_resources_absent)(this); }

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

public:
/* Befriend all modes                                                     */
friend  void QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
friend  void QUEX_NAME(M_on_buffer_before_change)(void* aux);
friend  void QUEX_NAME(M_on_buffer_overflow)(void* aux);
friend  void QUEX_NAME(M_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
friend  void QUEX_NAME(M_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
friend  void QUEX_NAME(M_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif
friend  void QUEX_NAME(M2_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M2_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M2_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
friend  bool QUEX_NAME(M2_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
friend  void QUEX_NAME(M2_on_buffer_before_change)(void* aux);
friend  void QUEX_NAME(M2_on_buffer_overflow)(void* aux);
friend  void QUEX_NAME(M2_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
friend  void QUEX_NAME(M2_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
friend  void QUEX_NAME(M2_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif

private:
TestAnalyzer(const TestAnalyzer&);                   /* Forbidden */
TestAnalyzer& operator=(const TestAnalyzer& Other); /* Forbidden */

};

QUEX_NAMESPACE_MAIN_CLOSE



#include "test_environment/lib/analyzer/headers.i"
/* START: User defined header content _________________________________________
*        The 'footer' content relies on class definitions made above.        */



#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED______TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER

QUEX_NAMESPACE_MAIN_OPEN

#if defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE void
QUEX_NAME(member_functions_assign)(QUEX_TYPE_ANALYZER* me)
{

}
#endif

bool
QUEX_NAME(user_constructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_destructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
QUEX_NAME(user_reset)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's 'reset' ______________________________________________________*/
return UserReset_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_print)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
QUEX_NAME(user_memento_pack)(QUEX_TYPE_ANALYZER* me, 
                             const char*         InputName, 
                             QUEX_NAME(Memento)* memento) 
{
    (void)me; (void)memento; (void)InputName;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'pack' _______________________________________________*/
return UserMementoPack_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                               QUEX_NAME(Memento)*  memento)
{
    (void)me; (void)memento;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

QUEX_NAMESPACE_MAIN_CLOSE




bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */

#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER
#include "test_environment/TestAnalyzer-token"
QUEX_NAMESPACE_TOKEN_OPEN
TestAnalyzer_lexatom_t   QUEX_NAME(LexemeNull) = (TestAnalyzer_lexatom_t)0;
QUEX_NAMESPACE_TOKEN_CLOSE

#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
