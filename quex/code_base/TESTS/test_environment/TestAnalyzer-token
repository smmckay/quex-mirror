/* -*- C++ -*-   vim: set syntax=cpp:
* (C) 2004-2009 Frank-Rene Schaefer
* ABSOLUTELY NO WARRANTY
*/
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN


#   line 2 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

#include <stddef.h>
#include <iostream>
#include <string>
#include <test_environment/lib/compatibility/stdint.h>
#include <test_environment/lib/definitions>
#include <test_environment/lib/asserts>
#include <test_environment/lib/MemoryManager>
#include <test_environment/lib/lexeme_base>
#include <test_environment/converter-from-lexeme>



#   line 22 "test_environment/TestAnalyzer-token"



#include "test_environment/TestAnalyzer-configuration"



class TestAnalyzer_Token;

inline void         TestAnalyzer_Token_construct(TestAnalyzer_Token*);
inline void         TestAnalyzer_Token_copy(TestAnalyzer_Token*, const TestAnalyzer_Token*);
inline void         TestAnalyzer_Token_destruct(TestAnalyzer_Token*);

/* NOTE: Setters and getters as in the C++ version of the token class are not
*       necessary, since the members are accessed directly.                   */

inline void         TestAnalyzer_Token_set(TestAnalyzer_Token*            me,
const TestAnalyzer_token_id_t ID);

inline const char*  TestAnalyzer_Token_map_id_to_name(const TestAnalyzer_token_id_t);

#ifdef QUEX_OPTION_TOKEN_TAKE_TEXT_SUPPORT
inline bool         TestAnalyzer_Token_take_text(TestAnalyzer_Token*            me,
const TestAnalyzer_lexatom_t* Begin,
const TestAnalyzer_lexatom_t* End);
#endif

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
inline size_t       TestAnalyzer_Token_repetition_n_get(TestAnalyzer_Token*);
inline void         TestAnalyzer_Token_repetition_n_set(TestAnalyzer_Token*, size_t);
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */


class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer_Token {
public:
TestAnalyzer_Token();
TestAnalyzer_Token(const TestAnalyzer_Token& That);
/* operator=(..): USE WITH CAUTION--POSSIBLE MAJOR PERFORMANCE DECREASE!
*                BETTER USE __copy(That)                                */
TestAnalyzer_Token& operator=(const TestAnalyzer_Token& That);
virtual ~TestAnalyzer_Token();


#   line 20 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
const TestAnalyzer_lexatom_t* text;

#   line 67 "test_environment/TestAnalyzer-token"


#   line 21 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
size_t                   number;

#   line 71 "test_environment/TestAnalyzer-token"



public:

#   line 20 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
const TestAnalyzer_lexatom_t* get_text() const                           { return text; }
#   line 20 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
void                     set_text(const TestAnalyzer_lexatom_t*& Value)  { text = Value; }
#   line 21 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
size_t                   get_number() const                         { return number; }
#   line 21 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"
void                     set_number(size_t Value)                   { number = Value; }

#   line 84 "test_environment/TestAnalyzer-token"


void set(const TestAnalyzer_token_id_t ID) { id = ID; }
void set(const TestAnalyzer_token_id_t ID, const  TestAnalyzer_lexatom_t*& Value0, const size_t& Value1)
{ id = ID; text = Value0; number = Value1; }


public:
/* _line_n, _column_n, and id are public, so that the token policy
* can access it. making it private would imply complications for
* user customized token classes. The token policies should be the
* same for C and Cpp.                                               */
TestAnalyzer_token_id_t    id;
const char*           id_name() const;

#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#       ifdef QUEX_OPTION_COUNTER_LINE
public:
TestAnalyzer_token_line_n_t    _line_n;
TestAnalyzer_token_line_n_t    line_number() const                                 { return _line_n; }
void                      set_line_number(const TestAnalyzer_token_line_n_t Value) { _line_n = Value; }
#       endif
#       ifdef  QUEX_OPTION_COUNTER_COLUMN
public:
TestAnalyzer_token_column_n_t  _column_n;
TestAnalyzer_token_column_n_t  column_number() const                                   { return _column_n; }
void                      set_column_number(const TestAnalyzer_token_column_n_t Value) { _column_n = Value; }
#       endif
#   endif
public:
#   define self (*this)

#   line 106 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

operator
const std::string() const
{ return std::string(get_string()); }

const std::string
get_string() const
{
std::string  tmp(TestAnalyzer_Token_map_id_to_name(self.id));
tmp += " '" + TestAnalyzer_lexeme_to_pretty_char(self.text) + "'";
return tmp;
}



#   line 131 "test_environment/TestAnalyzer-token"


#   undef  self

private:
friend void TestAnalyzer_Token_copy(TestAnalyzer_Token*       __this,
const TestAnalyzer_Token* That);
friend bool TestAnalyzer_Token_take_text(TestAnalyzer_Token*             __this,
const TestAnalyzer_lexatom_t*  Begin,
const TestAnalyzer_lexatom_t*  End);
};




#   line 130 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"


inline std::ostream&
operator<<(std::ostream& ostr, const TestAnalyzer_Token& Tok)
{ ostr << Tok.get_string(); return ostr; }

#include <test_environment/converter-from-lexeme.i>
#include <test_environment/lib/lexeme_base.i>


#   line 156 "test_environment/TestAnalyzer-token"



extern TestAnalyzer_lexatom_t TestAnalyzer_LexemeNull;

#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN */

/* This content is pasted into header, so the include guard is superfluous.
* It is left in place, so that if some time later the code generator is
* adapted to generate independent files, it will still work safely.          */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN_I
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN_I

#include "test_environment/TestAnalyzer-token"
#include "test_environment/TestAnalyzer-token_ids"



inline
TestAnalyzer_Token::TestAnalyzer_Token()
{
#   define self (*this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)

#   line 26 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

self.number = 0;
self.text   = LexemeNull;


#   line 185 "test_environment/TestAnalyzer-token"


#   undef  LexemeNull
#   undef  self
}

inline
TestAnalyzer_Token::TestAnalyzer_Token(const TestAnalyzer_Token& Other)
{
TestAnalyzer_Token_copy(this, &Other);
#   define self (*this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)

#   line 26 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

self.number = 0;
self.text   = LexemeNull;


#   line 203 "test_environment/TestAnalyzer-token"


#   undef  LexemeNull
#   undef  self
}

inline
TestAnalyzer_Token::~TestAnalyzer_Token()
{
#   define self (*this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)

#   line 31 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

if( self.text != LexemeNull ) {
QUEXED(MemoryManager_free)((void*)self.text,
E_MemoryObjectType_TEXT);
self.text = LexemeNull;
}


#   line 223 "test_environment/TestAnalyzer-token"


#   undef  LexemeNull
#   undef  self
}

inline TestAnalyzer_Token&
TestAnalyzer_Token::operator=(const TestAnalyzer_Token& That)
{ if( this != &That ) { TestAnalyzer_Token_copy(this, &That); } return *this; }

inline const char*
TestAnalyzer_Token::id_name() const
{ return TestAnalyzer_Token_map_id_to_name(id); }

inline void
TestAnalyzer_Token_construct(TestAnalyzer_Token* __this)
{
/* Explicit constructor call by 'placement new' */
new ((void*)__this) TestAnalyzer_Token;
}

inline void
TestAnalyzer_Token_destruct(TestAnalyzer_Token* __this)
{
if( ! __this ) return;
__this->TestAnalyzer_Token::~TestAnalyzer_Token();
}

inline void
TestAnalyzer_Token_copy(TestAnalyzer_Token* __this, const TestAnalyzer_Token* __That)
{
#   define self  (*__this)
#   define Other (*__That)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
(void)__this;
(void)__That;

#   line 39 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

self.id  = Other.id;

if( self.text != LexemeNull ) {
QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
}
if( Other.text != LexemeNull ) {
self.text = TestAnalyzer_lexeme_clone(self.text,
TestAnalyzer_lexeme_length(Other.text));
if( ! self.text ) self.text = LexemeNull;
}
self.number = Other.number;
#   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
__QUEX_IF_COUNT_LINES(self._line_n     = Other._line_n);
__QUEX_IF_COUNT_COLUMNS(self._column_n = Other._column_n);
#   endif


#   line 278 "test_environment/TestAnalyzer-token"


#   undef LexemeNull
#   undef Other
#   undef self
/* If the user even misses to copy the token id, then there's
* something seriously wrong.                                 */
__quex_assert(__this->id == __That->id);
#ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
#   ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
__QUEX_IF_COUNT_LINES(__quex_assert(__this->_line_n == __That->_line_n));
__QUEX_IF_COUNT_COLUMNS(__quex_assert(__this->_column_n == __That->_column_n));
#   endif
#endif
}

#ifdef QUEX_OPTION_TOKEN_TAKE_TEXT_SUPPORT
inline bool
TestAnalyzer_Token_take_text(TestAnalyzer_Token*              __this,
const TestAnalyzer_lexatom_t* Begin,
const TestAnalyzer_lexatom_t* End)
/* RETURNS: true -- if the token claims ownership over the given memory.
*          false -- if no ownership is claimed.                             */
{
#   define self      (*__this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
(void)__this;

#   line 57 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"


#       if 0
/* Hint for debug: To check take_text change "#if 0" to "#if 1" */
{
const TestAnalyzer_lexatom_t* it = (void*)0x0;
printf("previous:  '");
if( self.text != LexemeNull ) {
for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
printf("%04X.", (int)*it);
}
printf("'\n");
printf("take_text: '");
for(it = Begin; it != End; ++it) printf("%04X.", (int)*it);
printf("%04X.", (int)*it);
printf("'\n");
}
#       endif

if( self.text != LexemeNull ) {
QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
}
if( Begin != LexemeNull ) {
__quex_assert(End >= Begin);
self.text = TestAnalyzer_lexeme_clone(Begin, (size_t)(End - Begin));
if( ! self.text ) self.text = LexemeNull;
*((TestAnalyzer_lexatom_t*)(self.text + (End - Begin))) = (TestAnalyzer_lexatom_t)0;
} else {
self.text = LexemeNull;
}

#       if 0
/* Hint for debug: To check take_text change "#if 0" to "#if 1"       */
{
const TestAnalyzer_lexatom_t* it = 0x0;
printf("after:     '");
if( self.text != LexemeNull ) {
for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
printf("%04X.", (int)*it);
}
printf("'\n");
}
#       endif

/* This token copied the text from the chunk into the string,
* so we do not claim ownership over it.                             */
return false;


#   line 355 "test_environment/TestAnalyzer-token"


#   undef  LexemeNull
#   undef  self
/* Default: no ownership.                                                */
return false;
}
#endif

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
inline size_t
TestAnalyzer_Token_repetition_n_get(TestAnalyzer_Token* __this)
{
#   define self (*__this)
(void)__this;

#   line 126 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

return self.number;


#   line 375 "test_environment/TestAnalyzer-token"


#   undef self
}

inline void
TestAnalyzer_Token_repetition_n_set(TestAnalyzer_Token* __this, size_t N)
{
#   define self (*__this)
(void)__this; (void)N;

#   line 122 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CppDefault.qx"

self.number = N;


#   line 390 "test_environment/TestAnalyzer-token"


#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

inline const char*
TestAnalyzer_Token_map_id_to_name(const TestAnalyzer_token_id_t TokenID)
{
switch( TokenID ) {
default: {
return "<NUMERIC VALUE OF TOKEN-ID UNDEFINED>";
}

case QUEX_TKN_TERMINATION:    return "<TERMINATION>";
case QUEX_TKN_UNINITIALIZED:  return "<UNINITIALIZED>";
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
case QUEX_TKN_INDENT:         return "<INDENT>";
case QUEX_TKN_DEDENT:         return "<DEDENT>";
case QUEX_TKN_NODENT:         return "<NODENT>";
#  endif
case QUEX_TKN_X:             return "X";


}
}



#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED______TESTANALYZER_TOKEN_I */
