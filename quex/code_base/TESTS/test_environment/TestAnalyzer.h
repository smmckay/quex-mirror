/* -*- C++ -*-   vim: set syntax=cpp:
* CONTENT:
*
* (1) Includes for required standard headers.
* (2) Definitions of options and settings for the particular application.
* (3) #include "test_environment/lib/definitions"
* (4) Lexical FSM class TestAnalyzer and its memento class.
* (5) Constructor and init core of TestAnalyzer.
* (6) Memento pack and unpack functions.
*
* File content generated by Quex 0.68.2.
*
* (C) 2005-2012 Frank-Rene Schaefer
* ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
/* In case that multiple lexical analyzers are used the same header
* files are compiled with a different setting of the macros. The
* undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#include "test_environment/lib/include-guard-undef"
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_

#include <stddef.h>
#include "test_environment/lib/compatibility/stdint.h"
#include "test_environment/TestAnalyzer-configuration.h"

#include "test_environment/lib/definitions"

QUEX_NAMESPACE_MAIN_OPEN
struct QUEX_NAME(Engine_tag);
struct QUEX_NAME(Memento_tag);
QUEX_TYPE0_ANALYZER;    /* TestAnalyzer */
typedef void  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE0_ANALYZER*);

/* Token Class Declaration must preceed the user's header, so that the user
* can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content ___________________________________________
*        Must come before token class definition, since the token class
*        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#include "test_environment/lib/analyzer/headers"

#include "test_environment/TestAnalyzer-token_ids.h"
#include "test_environment/TestAnalyzer-token.h"

QUEX_NAMESPACE_MAIN_OPEN

extern QUEX_NAME(Mode)  QUEX_NAME(M);
extern QUEX_NAME(Mode)  QUEX_NAME(M2);


extern  void QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
extern  void QUEX_NAME(M_on_buffer_before_change)(void* aux);
extern  void QUEX_NAME(M_on_buffer_overflow)(void* aux);
extern  void QUEX_NAME(M_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
extern  void QUEX_NAME(M_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void QUEX_NAME(M_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif
extern  void QUEX_NAME(M2_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M2_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
extern  void QUEX_NAME(M2_on_buffer_before_change)(void* aux);
extern  void QUEX_NAME(M2_on_buffer_overflow)(void* aux);
extern  void QUEX_NAME(M2_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
extern  void QUEX_NAME(M2_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void QUEX_NAME(M2_on_indentation)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif


typedef bool (*QUEX_NAME(callback_on_token_type))(QUEX_TYPE_TOKEN*);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG QUEX_NAME(Memento_tag) {
/* __( Data Members )_______________________________________________________
*                                                                        */
char*                           __input_name;
QUEX_NAME(Buffer)               buffer;

const struct QUEX_NAME(Mode_tag)* __current_mode_p;
QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct QUEX_NAME(Memento_tag)*  _parent_memento;
/* __( END: Data Members )________________________________________________*/

/* Con- and Destruction are **not** necessary in C. No con- or de-
* structors of members need to be triggered.                             */

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/
} QUEX_NAME(Memento);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer_tag {
/* __( Data Members )_______________________________________________________
*                                                                        */
QUEX_NAME(Buffer)               buffer;
QUEX_NAME(TokenQueue)           _token_queue;
QUEX_NAME(ModeStack)            _mode_stack;

E_Error                         error_code;
char*                           __input_name;

const QUEX_NAME(Mode)*          __current_mode_p;
/* Shortcut to current mode's analyzer function.                          */
QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
/* Backup of analyzer's function pointer => mode change detection.        */
QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct QUEX_NAME(Memento_tag)*  _parent_memento;
/*__( Reset )_______________________________________________________________
*                                                                        */
bool (*reset)(QUEX_TYPE_ANALYZER* me);
bool (*reset_file_name)(QUEX_TYPE_ANALYZER* me, const char* FileName, QUEX_NAME(Converter)* Converter);
bool (*reset_ByteLoader)(QUEX_TYPE_ANALYZER* me, QUEX_NAME(ByteLoader)* byte_loader, QUEX_NAME(Converter)* Converter);
bool (*reset_memory)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP);

/*__( Include From and To Substream )_______________________________________
*                                                                        */
bool (*include_push_file_name)(QUEX_TYPE_ANALYZER* me, const char* FileName, QUEX_NAME(Converter)* Converter);
bool (*include_push_ByteLoader)(QUEX_TYPE_ANALYZER* me, const char* InputName, QUEX_NAME(ByteLoader)* byte_loader, QUEX_NAME(Converter)* Converter);
bool (*include_push_memory)(QUEX_TYPE_ANALYZER* me, const char* InputName, TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP);
bool (*include_pop)(QUEX_TYPE_ANALYZER* me);
void (*include_stack_delete)(QUEX_TYPE_ANALYZER* me);
bool (*include_detect_recursion)(QUEX_TYPE_ANALYZER* me, const char* InputName);

/*__( Receiving Tokens -- from outside lexer )_____________________________
*                                                                       */
bool (*run)(QUEX_TYPE_ANALYZER* me, QUEX_NAME(callback_on_token_type) on_token, bool ErrorPrintF);
void (*receive)(QUEX_TYPE_ANALYZER* me, QUEX_TYPE_TOKEN** token_pp);

/*__( Sending Tokens -- from inside lexer )________________________________
*                                                                       */
QUEX_TYPE_TOKEN* (*token_p)(QUEX_TYPE_ANALYZER* me);

void (*send)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_token_id_t Id);
void (*send_n)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_token_id_t Id, size_t RepetitionN);
bool (*send_text)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* BeginP, TestAnalyzer_lexatom_t* EndP);
bool (*send_string)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* ZeroTerminatedString);

/*__( Mode Handling )______________________________________________________
*                                                                       */
const QUEX_NAME(Mode)* (*mode)(QUEX_TYPE_ANALYZER* me);
void (*set_mode_brutally)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* Mode);
void (*enter_mode)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* TargetMode);

void (*pop_mode)(QUEX_TYPE_ANALYZER* me);
void (*pop_drop_mode)(QUEX_TYPE_ANALYZER* me);
void (*push_mode)(QUEX_TYPE_ANALYZER* me, QUEX_NAME(Mode)* new_mode);

/*__( Line/Column Counter )________________________________________________
*                                                                       */
size_t (*line_number)(const QUEX_TYPE_ANALYZER* me);
size_t (*line_number_at_begin)(const QUEX_TYPE_ANALYZER* me);
size_t (*line_number_at_end)(const QUEX_TYPE_ANALYZER* me);
void (*line_number_set)(QUEX_TYPE_ANALYZER* me, size_t Y);

size_t (*column_number)(const QUEX_TYPE_ANALYZER* me);
size_t (*column_number_at_begin)(const QUEX_TYPE_ANALYZER* me);
size_t (*column_number_at_end)(const QUEX_TYPE_ANALYZER* me);
void (*column_number_set)(QUEX_TYPE_ANALYZER* me, size_t X);

/*__( Indentation )________________________________________________________
*                                                                       */


/*__( General Information )________________________________________________
*                                                                       */
const char* (*version)(QUEX_TYPE_ANALYZER* me);
void (*print_this)(QUEX_TYPE_ANALYZER* me);
const char* (*input_name)(QUEX_TYPE_ANALYZER* me);
bool (*input_name_set)(QUEX_TYPE_ANALYZER* me, const char* InputName);

/*__( Navigation: Tell/Seek )______________________________________________
*                                                                       */
size_t (*tell)(QUEX_TYPE_ANALYZER* me);
void (*seek)(QUEX_TYPE_ANALYZER* me, const size_t CharacterIndex);
void (*seek_forward)(QUEX_TYPE_ANALYZER* me, const size_t CharacterN);
void (*seek_backward)(QUEX_TYPE_ANALYZER* me, const size_t CharacterN);

void (*undo)(QUEX_TYPE_ANALYZER* me);
void (*undo_n)(QUEX_TYPE_ANALYZER* me, size_t DeltaN_Backward);

/*__( Byte Order Reversion Activation / Deactivation )_____________________
*                                                                       */
bool (*byte_order_reversion)(QUEX_TYPE_ANALYZER* me);
void (*byte_order_reversion_set)(QUEX_TYPE_ANALYZER* me, bool Value);

/*__( Error Codes )________________________________________________________
*                                                                       */
void (*error_code_clear)(QUEX_TYPE_ANALYZER* me);
bool (*error_code_is_void)(QUEX_TYPE_ANALYZER* me);
void (*error_code_set_void)(QUEX_TYPE_ANALYZER* me);
void (*error_code_set_if_first)(QUEX_TYPE_ANALYZER* me, E_Error ErrorCode);

/*__( Deep Resources )_____________________________________________________
*                                                                       */
void (*collect_user_memory)(QUEX_TYPE_ANALYZER* me, TestAnalyzer_lexatom_t** user_memory_p);
void (*resources_absent_mark)(QUEX_TYPE_ANALYZER* me);
bool (*resources_absent)(QUEX_TYPE_ANALYZER* me);

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

} TestAnalyzer;

#if defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE void QUEX_NAME(member_functions_assign)(QUEX_TYPE_ANALYZER* me);
#endif



#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER

QUEX_NAMESPACE_MAIN_OPEN

#if defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE void
QUEX_NAME(member_functions_assign)(QUEX_TYPE_ANALYZER* me)
{
    me->reset = QUEX_NAME(MF_reset);
    me->reset_file_name = QUEX_NAME(MF_reset_file_name);
    me->reset_ByteLoader = QUEX_NAME(MF_reset_ByteLoader);
    me->reset_memory = QUEX_NAME(MF_reset_memory);
    me->include_push_file_name = QUEX_NAME(MF_include_push_file_name);
    me->include_push_ByteLoader = QUEX_NAME(MF_include_push_ByteLoader);
    me->include_push_memory = QUEX_NAME(MF_include_push_memory);
    me->include_pop = QUEX_NAME(MF_include_pop);
    me->include_stack_delete = QUEX_NAME(MF_include_stack_delete);
    me->include_detect_recursion = QUEX_NAME(MF_include_detect_recursion);
    me->run = QUEX_NAME(MF_run);
    me->receive = QUEX_NAME(MF_receive);
    me->token_p = QUEX_NAME(MF_token_p);
    me->send = QUEX_NAME(MF_send);
    me->send_n = QUEX_NAME(MF_send_n);
    me->send_text = QUEX_NAME(MF_send_text);
    me->send_string = QUEX_NAME(MF_send_string);
    me->mode = QUEX_NAME(MF_mode);
    me->set_mode_brutally = QUEX_NAME(MF_set_mode_brutally);
    me->enter_mode = QUEX_NAME(MF_enter_mode);
    me->pop_mode = QUEX_NAME(MF_pop_mode);
    me->pop_drop_mode = QUEX_NAME(MF_pop_drop_mode);
    me->push_mode = QUEX_NAME(MF_push_mode);
    me->line_number = QUEX_NAME(MF_line_number);
    me->line_number_at_begin = QUEX_NAME(MF_line_number_at_begin);
    me->line_number_at_end = QUEX_NAME(MF_line_number_at_end);
    me->line_number_set = QUEX_NAME(MF_line_number_set);
    me->column_number = QUEX_NAME(MF_column_number);
    me->column_number_at_begin = QUEX_NAME(MF_column_number_at_begin);
    me->column_number_at_end = QUEX_NAME(MF_column_number_at_end);
    me->column_number_set = QUEX_NAME(MF_column_number_set);
    me->version = QUEX_NAME(MF_version);
    me->print_this = QUEX_NAME(MF_print_this);
    me->input_name = QUEX_NAME(MF_input_name);
    me->input_name_set = QUEX_NAME(MF_input_name_set);
    me->tell = QUEX_NAME(MF_tell);
    me->seek = QUEX_NAME(MF_seek);
    me->seek_forward = QUEX_NAME(MF_seek_forward);
    me->seek_backward = QUEX_NAME(MF_seek_backward);
    me->undo = QUEX_NAME(MF_undo);
    me->undo_n = QUEX_NAME(MF_undo_n);
    me->byte_order_reversion = QUEX_NAME(MF_byte_order_reversion);
    me->byte_order_reversion_set = QUEX_NAME(MF_byte_order_reversion_set);
    me->error_code_clear = QUEX_NAME(MF_error_code_clear);
    me->error_code_is_void = QUEX_NAME(MF_error_code_is_void);
    me->error_code_set_void = QUEX_NAME(MF_error_code_set_void);
    me->error_code_set_if_first = QUEX_NAME(MF_error_code_set_if_first);
    me->collect_user_memory = QUEX_NAME(MF_collect_user_memory);
    me->resources_absent_mark = QUEX_NAME(MF_resources_absent_mark);
    me->resources_absent = QUEX_NAME(MF_resources_absent);
}
#endif

bool
QUEX_NAME(user_constructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_destructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
QUEX_NAME(user_reset)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's 'reset' ______________________________________________________*/
return UserReset_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_print)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
QUEX_NAME(user_memento_pack)(QUEX_TYPE_ANALYZER* me, 
                             const char*         InputName, 
                             QUEX_NAME(Memento)* memento) 
{
    (void)me; (void)memento; (void)InputName;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'pack' _______________________________________________*/
return UserMementoPack_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                               QUEX_NAME(Memento)*  memento)
{
    (void)me; (void)memento;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

QUEX_NAMESPACE_MAIN_CLOSE



#include "ut/lib/analyzer/headers.i"
#include "ut/lib/analyzer/C-adaptions.h"


/* START: User defined header content _________________________________________
 *        The 'footer' content relies on class definitions made above.        */



bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */

#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER
/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TOKEN_I
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TOKEN_I

#ifndef    __QUEX_OPTION_PLAIN_C
#   define __QUEX_OPTION_PLAIN_C
#endif

#include "test_environment/TestAnalyzer-token.h"
#include "test_environment/TestAnalyzer-token_ids.h"
#include "ut/lib/lexeme_base.i"

QUEX_INLINE void 
Token_set(Token*            __this, 
                 const TestAnalyzer_token_id_t ID) 
{ __this->id = ID; }

QUEX_INLINE void 
Token_construct(Token* __this)
{
#   define self (*__this)
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    (void)__this;

#   line 25 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       self.number = 0;
       self.text   = LexemeNull;
   

#   line 463 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void 
Token_copy_construct(Token*       __this, 
                            const Token* __That)
{
    QUEX_NAME_TOKEN(construct)(__this);
    QUEX_NAME_TOKEN(copy)(__this, __That);
}

QUEX_INLINE void 
Token_destruct(Token* __this)
{
#   define self (*__this)
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    if( ! __this ) return;


#   line 30 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       if( self.text != LexemeNull ) {
           QUEXED(MemoryManager_free)((void*)self.text,
                                      E_MemoryObjectType_TEXT);
           self.text = LexemeNull;
       }
   

#   line 494 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void
Token_copy(Token*       __this, 
                  const Token* __That)
{
#   define self  (*__this)
#   define Other (*__That)
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    (void)__this;
    (void)__That;

#   line 38 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

        self.id  = Other.id;

        if( self.text != LexemeNull ) {
            QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
        }
        if( Other.text != LexemeNull ) {
            self.text = QUEX_NAME(lexeme_clone)(self.text, 
                                                      QUEX_NAME(lexeme_length)(Other.text));
            if( ! self.text ) self.text = LexemeNull;
        }
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
        __QUEX_IF_COUNT_LINES(self._line_n     = Other._line_n);
        __QUEX_IF_COUNT_COLUMNS(self._column_n = Other._column_n);
    #   endif
   

#   line 529 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  Other
#   undef  self
    /* If the user even misses to copy the token id, then there's
     * something seriously wrong.                                 */
    __quex_assert(__this->id == __That->id);
#   ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    __QUEX_IF_COUNT_LINES(__quex_assert(__this->_line_n == __That->_line_n));
    __QUEX_IF_COUNT_COLUMNS(__quex_assert(__this->_column_n == __That->_column_n));
#   endif
}


#ifdef QUEX_OPTION_TOKEN_TAKE_TEXT_SUPPORT
QUEX_INLINE bool 
Token_take_text(Token*            __this, 
                       const TestAnalyzer_lexatom_t* Begin, 
                       const TestAnalyzer_lexatom_t* End)
/* RETURNS: true -- if the token claims ownership over the given memory.
 *          false -- if no ownership is claimed.                             */
{
#   define self       (*__this)
#   ifdef  LexemeNull
#   error  "Error LexemeNull shall not be defined here."
#   endif
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    (void)__this;
    (void)Begin;
    (void)End;

#   line 56 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"


#       if 0
        /* Hint for debug: To check take_text change "#if 0" to "#if 1" */
        {
            const TestAnalyzer_lexatom_t* it = (void*)0x0;
            printf("previous:  '");
            if( self.text != LexemeNull ) {
                for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
                printf("%04X.", (int)*it);
            }
            printf("'\n");
            printf("take_text: '");
            for(it = Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        if( self.text != LexemeNull ) {
            QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
        }
        if( Begin != LexemeNull ) {
            __quex_assert(End >= Begin);
            self.text = QUEX_NAME(lexeme_clone)(Begin, (size_t)(End - Begin));
            if( ! self.text ) self.text = LexemeNull;
            *((TestAnalyzer_lexatom_t*)(self.text + (End - Begin))) = (TestAnalyzer_lexatom_t)0;
        } else {
            self.text = LexemeNull;
        }

#       if 0
        /* Hint for debug: To check take_text change "#if 0" to "#if 1"       */
        {
            const TestAnalyzer_lexatom_t* it = 0x0;
            printf("after:     '");
            if( self.text != LexemeNull ) { 
                for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
                printf("%04X.", (int)*it);
            }
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim ownership over it.                             */
        return false;
   

#   line 611 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
    /* Default: no ownership.                                                */
    return false;
}
#endif

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
QUEX_INLINE size_t 
Token_repetition_n_get(Token* __this)
{
#   define self        (*__this)
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    (void)__this;

#   line 113 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       return self.number;
   

#   line 633 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void 
Token_repetition_n_set(Token* __this, size_t N)
{
#   define self        (*__this)
#   define LexemeNull  (&QUEX_NAME(LexemeNull))
    (void)__this;
    (void)N;

#   line 109 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       self.number = N;
   

#   line 652 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

QUEX_INLINE const char*
Token_map_id_to_name(const TestAnalyzer_token_id_t TokenID)
{
   static char  error_string[64];

   /* NOTE: This implementation works only for token id types that are 
    *       some type of integer or enum. In case an alien type is to
    *       used, this function needs to be redefined.                  */
   switch( TokenID ) {
   default: {
       __QUEX_STD_sprintf(error_string, "<UNKNOWN TOKEN-ID: %i>", (int)TokenID);
       return error_string;
   }

   case QUEX_TKN_TERMINATION:    return "<TERMINATION>";
   case QUEX_TKN_UNINITIALIZED:  return "<UNINITIALIZED>";
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   case QUEX_TKN_INDENT:         return "<INDENT>";
   case QUEX_TKN_DEDENT:         return "<DEDENT>";
   case QUEX_TKN_NODENT:         return "<NODENT>";
#  endif
   case QUEX_TKN_X:             return "X";


   }
}


#   line 117 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

        const char* 
        Token_get_string(Token* me, char*   buffer, size_t  BufferSize) 
        {
            const char*  token_id_str = Token_map_id_to_name(me->id);
            const char*  BufferEnd    = buffer + BufferSize;
            char*        writerator   = 0;

            if( ! BufferSize ) return NULL;

            /* Token Type */
            writerator = buffer; 
            writerator += __QUEX_STD_strlcpy(writerator, token_id_str, 
                                             BufferEnd - writerator);

            /* Opening Quote */
            if( BufferEnd - writerator > 2 ) {
                *writerator++ = ' ';
                *writerator++ = '\'';
            }

            /* The String */
            writerator = QUEX_NAME(lexeme_to_pretty_char)(me->text, writerator, BufferEnd);

            /* Closing Quote */
            if( BufferEnd - writerator > 1 ) {
                *writerator++ = '\'';
            }
            *writerator = '\0';
            return buffer;
        }

#include "test_environment/converter-from-lexeme.i"
   

#   line 723 "TestAnalyzer.h"


#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TOKEN_I */
QUEX_NAMESPACE_TOKEN_OPEN
TestAnalyzer_lexatom_t   QUEX_NAME(LexemeNull) = (TestAnalyzer_lexatom_t)0;
QUEX_NAMESPACE_TOKEN_CLOSE

#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
