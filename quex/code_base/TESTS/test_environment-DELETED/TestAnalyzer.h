/* -*- C++ -*-   vim: set syntax=cpp:
* CONTENT:
*
* (1) Includes for required standard headers.
* (2) Definitions of options and settings for the particular application.
* (3) #include "test_environment/lib/definitions"
* (4) Lexical FSM class TestAnalyzer and its memento class.
* (5) Constructor and init core of TestAnalyzer.
* (6) Memento pack and unpack functions.
*
* File content generated by Quex 0.68.2.
*
* (C) 2005-2012 Frank-Rene Schaefer
* ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
/* In case that multiple lexical analyzers are used the same header
* files are compiled with a different setting of the macros. The
* undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#include "test_environment/lib/include-guard-undef"
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE_

#include <stddef.h>
#include "test_environment/lib/quex/compatibility/stdint.h"
#include "test_environment/TestAnalyzer-configuration.h"

#include "test_environment/lib/definitions"


struct TestAnalyzer_Engine_tag;
struct TestAnalyzer_Memento_tag;
struct TestAnalyzer_tag;    /* TestAnalyzer */
typedef void  (*TestAnalyzer_AnalyzerFunctionP)(struct TestAnalyzer_tag*);

/* Token Class Declaration must preceed the user's header, so that the user
* can refer to it at ease.                                                    */

struct TestAnalyzer_Token_tag;


/* START: User defined header content ___________________________________________
*        Must come before token class definition, since the token class
*        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#include "test_environment/lib/declarations"

#include "test_environment/TestAnalyzer-token_ids.h"
#include "test_environment/TestAnalyzer-token.h"



extern TestAnalyzer_Mode  TestAnalyzer_M;
extern TestAnalyzer_Mode  TestAnalyzer_M2;


extern  void TestAnalyzer_M_analyzer_function(struct TestAnalyzer_tag* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M_has_base(const TestAnalyzer_Mode* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M_has_entry_from(const TestAnalyzer_Mode* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M_has_exit_to(const TestAnalyzer_Mode* mode);
#endif
extern  void TestAnalyzer_M_on_buffer_before_change(void* aux);
extern  void TestAnalyzer_M_on_buffer_overflow(void* aux);
extern  void TestAnalyzer_M_on_entry(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* mode);
extern  void TestAnalyzer_M_on_exit(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void TestAnalyzer_M_on_indentation(struct TestAnalyzer_tag* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif
extern  void TestAnalyzer_M2_analyzer_function(struct TestAnalyzer_tag* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M2_has_base(const TestAnalyzer_Mode* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M2_has_entry_from(const TestAnalyzer_Mode* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool TestAnalyzer_M2_has_exit_to(const TestAnalyzer_Mode* mode);
#endif
extern  void TestAnalyzer_M2_on_buffer_before_change(void* aux);
extern  void TestAnalyzer_M2_on_buffer_overflow(void* aux);
extern  void TestAnalyzer_M2_on_entry(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* mode);
extern  void TestAnalyzer_M2_on_exit(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void TestAnalyzer_M2_on_indentation(struct TestAnalyzer_tag* me, TestAnalyzer_indentation_t Indentation, TestAnalyzer_lexatom_t* Lexeme);
#endif


typedef bool (*TestAnalyzer_callback_on_token_type)(struct TestAnalyzer_Token_tag*);

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer_Memento_tag {
/* __( Data Members )_______________________________________________________
*                                                                        */
char*                           __input_name;
TestAnalyzer_Buffer               buffer;

const struct TestAnalyzer_Mode_tag* __current_mode_p;
TestAnalyzer_AnalyzerFunctionP    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
TestAnalyzer_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
TestAnalyzer_Counter              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct TestAnalyzer_Memento_tag*  _parent_memento;
/* __( END: Data Members )________________________________________________*/

/* Con- and Destruction are **not** necessary in C. No con- or de-
* structors of members need to be triggered.                             */

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/
} TestAnalyzer_Memento;

typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer_tag {
/* __( Data Members )_______________________________________________________
*                                                                        */
TestAnalyzer_Buffer               buffer;
TestAnalyzer_TokenQueue           _token_queue;
TestAnalyzer_ModeStack            _mode_stack;

E_Error                         error_code;
char*                           __input_name;

const TestAnalyzer_Mode*          __current_mode_p;
/* Shortcut to current mode's analyzer function.                          */
TestAnalyzer_AnalyzerFunctionP    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
/* Backup of analyzer's function pointer => mode change detection.        */
TestAnalyzer_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
TestAnalyzer_Counter              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
bool                            _indentation_handler_active_f;
#   endif
struct TestAnalyzer_Memento_tag*  _parent_memento;
/*__( Reset )_______________________________________________________________
*                                                                        */
bool (*reset)(struct TestAnalyzer_tag* me);
bool (*reset_file_name)(struct TestAnalyzer_tag* me, const char* FileName, TestAnalyzer_Converter* Converter);
bool (*reset_ByteLoader)(struct TestAnalyzer_tag* me, TestAnalyzer_ByteLoader* byte_loader, TestAnalyzer_Converter* Converter);
bool (*reset_memory)(struct TestAnalyzer_tag* me, TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP);

/*__( Include From and To Substream )_______________________________________
*                                                                        */
bool (*include_push_file_name)(struct TestAnalyzer_tag* me, const char* FileName, TestAnalyzer_Converter* Converter);
bool (*include_push_ByteLoader)(struct TestAnalyzer_tag* me, const char* InputName, TestAnalyzer_ByteLoader* byte_loader, TestAnalyzer_Converter* Converter);
bool (*include_push_memory)(struct TestAnalyzer_tag* me, const char* InputName, TestAnalyzer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, TestAnalyzer_lexatom_t* BufferEndOfContentP);
bool (*include_pop)(struct TestAnalyzer_tag* me);
void (*include_stack_delete)(struct TestAnalyzer_tag* me);
bool (*include_detect_recursion)(struct TestAnalyzer_tag* me, const char* InputName);

/*__( Receiving Tokens -- from outside lexer )_____________________________
*                                                                       */
bool (*run)(struct TestAnalyzer_tag* me, TestAnalyzer_callback_on_token_type on_token, bool ErrorPrintF);
void (*receive)(struct TestAnalyzer_tag* me, struct TestAnalyzer_Token_tag** token_pp);

/*__( Sending Tokens -- from inside lexer )________________________________
*                                                                       */
struct TestAnalyzer_Token_tag* (*token_p)(struct TestAnalyzer_tag* me);

void (*send)(struct TestAnalyzer_tag* me, TestAnalyzer_token_id_t Id);
void (*send_n)(struct TestAnalyzer_tag* me, TestAnalyzer_token_id_t Id, size_t RepetitionN);
bool (*send_text)(struct TestAnalyzer_tag* me, TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* BeginP, TestAnalyzer_lexatom_t* EndP);
bool (*send_string)(struct TestAnalyzer_tag* me, TestAnalyzer_token_id_t Id, TestAnalyzer_lexatom_t* ZeroTerminatedString);

/*__( Mode Handling )______________________________________________________
*                                                                       */
const TestAnalyzer_Mode* (*mode)(struct TestAnalyzer_tag* me);
void (*set_mode_brutally)(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* Mode);
void (*enter_mode)(struct TestAnalyzer_tag* me, const TestAnalyzer_Mode* TargetMode);

void (*pop_mode)(struct TestAnalyzer_tag* me);
void (*pop_drop_mode)(struct TestAnalyzer_tag* me);
void (*push_mode)(struct TestAnalyzer_tag* me, TestAnalyzer_Mode* new_mode);

/*__( Line/Column Counter )________________________________________________
*                                                                       */
size_t (*line_number)(const struct TestAnalyzer_tag* me);
size_t (*line_number_at_begin)(const struct TestAnalyzer_tag* me);
size_t (*line_number_at_end)(const struct TestAnalyzer_tag* me);
void (*line_number_set)(struct TestAnalyzer_tag* me, size_t Y);

size_t (*column_number)(const struct TestAnalyzer_tag* me);
size_t (*column_number_at_begin)(const struct TestAnalyzer_tag* me);
size_t (*column_number_at_end)(const struct TestAnalyzer_tag* me);
void (*column_number_set)(struct TestAnalyzer_tag* me, size_t X);

/*__( Indentation )________________________________________________________
*                                                                       */


/*__( General Information )________________________________________________
*                                                                       */
const char* (*version)(struct TestAnalyzer_tag* me);
void (*print_this)(struct TestAnalyzer_tag* me);
const char* (*input_name)(struct TestAnalyzer_tag* me);
bool (*input_name_set)(struct TestAnalyzer_tag* me, const char* InputName);

/*__( Navigation: Tell/Seek )______________________________________________
*                                                                       */
size_t (*tell)(struct TestAnalyzer_tag* me);
void (*seek)(struct TestAnalyzer_tag* me, const size_t CharacterIndex);
void (*seek_forward)(struct TestAnalyzer_tag* me, const size_t CharacterN);
void (*seek_backward)(struct TestAnalyzer_tag* me, const size_t CharacterN);

void (*undo)(struct TestAnalyzer_tag* me);
void (*undo_n)(struct TestAnalyzer_tag* me, size_t DeltaN_Backward);

/*__( Byte Order Reversion Activation / Deactivation )_____________________
*                                                                       */
bool (*byte_order_reversion)(struct TestAnalyzer_tag* me);
void (*byte_order_reversion_set)(struct TestAnalyzer_tag* me, bool Value);

/*__( Error Codes )________________________________________________________
*                                                                       */
void (*error_code_clear)(struct TestAnalyzer_tag* me);
bool (*error_code_is_void)(struct TestAnalyzer_tag* me);
void (*error_code_set_void)(struct TestAnalyzer_tag* me);
void (*error_code_set_if_first)(struct TestAnalyzer_tag* me, E_Error ErrorCode);

/*__( Deep Resources )_____________________________________________________
*                                                                       */
void (*collect_user_memory)(struct TestAnalyzer_tag* me, TestAnalyzer_lexatom_t** user_memory_p);
void (*resources_absent_mark)(struct TestAnalyzer_tag* me);
bool (*resources_absent)(struct TestAnalyzer_tag* me);

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

} TestAnalyzer;

#if defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE void TestAnalyzer_member_functions_assign(struct TestAnalyzer_tag* me);
#endif



#include "test_environment/lib/implementations-inline.i"

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER



#if defined(__QUEX_OPTION_PLAIN_C)
QUEX_INLINE void
TestAnalyzer_member_functions_assign(struct TestAnalyzer_tag* me)
{
    me->reset = TestAnalyzer_MF_reset;
    me->reset_file_name = TestAnalyzer_MF_reset_file_name;
    me->reset_ByteLoader = TestAnalyzer_MF_reset_ByteLoader;
    me->reset_memory = TestAnalyzer_MF_reset_memory;
    me->include_push_file_name = TestAnalyzer_MF_include_push_file_name;
    me->include_push_ByteLoader = TestAnalyzer_MF_include_push_ByteLoader;
    me->include_push_memory = TestAnalyzer_MF_include_push_memory;
    me->include_pop = TestAnalyzer_MF_include_pop;
    me->include_stack_delete = TestAnalyzer_MF_include_stack_delete;
    me->include_detect_recursion = TestAnalyzer_MF_include_detect_recursion;
    me->run = TestAnalyzer_MF_run;
    me->receive = TestAnalyzer_MF_receive;
    me->token_p = TestAnalyzer_MF_token_p;
    me->send = TestAnalyzer_MF_send;
    me->send_n = TestAnalyzer_MF_send_n;
    me->send_text = TestAnalyzer_MF_send_text;
    me->send_string = TestAnalyzer_MF_send_string;
    me->mode = TestAnalyzer_MF_mode;
    me->set_mode_brutally = TestAnalyzer_MF_set_mode_brutally;
    me->enter_mode = TestAnalyzer_MF_enter_mode;
    me->pop_mode = TestAnalyzer_MF_pop_mode;
    me->pop_drop_mode = TestAnalyzer_MF_pop_drop_mode;
    me->push_mode = TestAnalyzer_MF_push_mode;
    me->line_number = TestAnalyzer_MF_line_number;
    me->line_number_at_begin = TestAnalyzer_MF_line_number_at_begin;
    me->line_number_at_end = TestAnalyzer_MF_line_number_at_end;
    me->line_number_set = TestAnalyzer_MF_line_number_set;
    me->column_number = TestAnalyzer_MF_column_number;
    me->column_number_at_begin = TestAnalyzer_MF_column_number_at_begin;
    me->column_number_at_end = TestAnalyzer_MF_column_number_at_end;
    me->column_number_set = TestAnalyzer_MF_column_number_set;
    me->version = TestAnalyzer_MF_version;
    me->print_this = TestAnalyzer_MF_print_this;
    me->input_name = TestAnalyzer_MF_input_name;
    me->input_name_set = TestAnalyzer_MF_input_name_set;
    me->tell = TestAnalyzer_MF_tell;
    me->seek = TestAnalyzer_MF_seek;
    me->seek_forward = TestAnalyzer_MF_seek_forward;
    me->seek_backward = TestAnalyzer_MF_seek_backward;
    me->undo = TestAnalyzer_MF_undo;
    me->undo_n = TestAnalyzer_MF_undo_n;
    me->byte_order_reversion = TestAnalyzer_MF_byte_order_reversion;
    me->byte_order_reversion_set = TestAnalyzer_MF_byte_order_reversion_set;
    me->error_code_clear = TestAnalyzer_MF_error_code_clear;
    me->error_code_is_void = TestAnalyzer_MF_error_code_is_void;
    me->error_code_set_void = TestAnalyzer_MF_error_code_set_void;
    me->error_code_set_if_first = TestAnalyzer_MF_error_code_set_if_first;
    me->collect_user_memory = TestAnalyzer_MF_collect_user_memory;
    me->resources_absent_mark = TestAnalyzer_MF_resources_absent_mark;
    me->resources_absent = TestAnalyzer_MF_resources_absent;
}
#endif

bool
TestAnalyzer_user_constructor(struct TestAnalyzer_tag* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
TestAnalyzer_user_destructor(struct TestAnalyzer_tag* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
TestAnalyzer_user_reset(struct TestAnalyzer_tag* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's 'reset' ______________________________________________________*/
return UserReset_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
TestAnalyzer_user_print(struct TestAnalyzer_tag* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
TestAnalyzer_user_memento_pack(struct TestAnalyzer_tag* me, 
                             const char*         InputName, 
                             TestAnalyzer_Memento* memento) 
{
    (void)me; (void)memento; (void)InputName;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'pack' _______________________________________________*/
return UserMementoPack_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
TestAnalyzer_user_memento_unpack(struct TestAnalyzer_tag*  me, 
                               TestAnalyzer_Memento*  memento)
{
    (void)me; (void)memento;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}






bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */

#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER
/* -*- C++ -*-   vim: set syntax=cpp: 
 * (C) 2004-2009 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY
 */
#ifndef __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TESTANALYZER_TOKEN_I
#define __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TESTANALYZER_TOKEN_I

#ifndef    __QUEX_OPTION_PLAIN_C
#   define __QUEX_OPTION_PLAIN_C
#endif

#include "test_environment/TestAnalyzer-token.h"
#include "test_environment/TestAnalyzer-token_ids.h"

QUEX_INLINE void 
TestAnalyzer_Token_set(TestAnalyzer_Token*            __this, 
                 const TestAnalyzer_token_id_t ID) 
{ __this->id = ID; }

QUEX_INLINE void 
TestAnalyzer_Token_construct(TestAnalyzer_Token* __this)
{
#   define self (*__this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    (void)__this;

#   line 35 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       self.number = 0;
       self.text   = LexemeNull;
   

#   line 456 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void 
TestAnalyzer_Token_copy_construct(TestAnalyzer_Token*       __this, 
                            const TestAnalyzer_Token* __That)
{
    TestAnalyzer_Token_construct(__this);
    TestAnalyzer_Token_copy(__this, __That);
}

QUEX_INLINE void 
TestAnalyzer_Token_destruct(TestAnalyzer_Token* __this)
{
#   define self (*__this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    if( ! __this ) return;


#   line 40 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       if( self.text != LexemeNull ) {
           QUEXED(MemoryManager_free)((void*)self.text,
                                      E_MemoryObjectType_TEXT);
           self.text = LexemeNull;
       }
   

#   line 487 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void
TestAnalyzer_Token_copy(TestAnalyzer_Token*       __this, 
                  const TestAnalyzer_Token* __That)
{
#   define self  (*__this)
#   define Other (*__That)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    (void)__this;
    (void)__That;

#   line 48 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

        self.id  = Other.id;

        if( self.text != LexemeNull ) {
            QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
        }
        if( Other.text != LexemeNull ) {
            self.text = TestAnalyzer_lexeme_clone(self.text, 
                                                      TestAnalyzer_lexeme_length(Other.text));
            if( ! self.text ) self.text = LexemeNull;
        }
        self.number = Other.number;
    #   ifdef     QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
        __QUEX_IF_COUNT_LINES(self._line_n     = Other._line_n);
        __QUEX_IF_COUNT_COLUMNS(self._column_n = Other._column_n);
    #   endif
   

#   line 522 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  Other
#   undef  self
    /* If the user even misses to copy the token id, then there's
     * something seriously wrong.                                 */
    __quex_assert(__this->id == __That->id);
#   ifdef QUEX_OPTION_TOKEN_STAMPING_WITH_LINE_AND_COLUMN
    __QUEX_IF_COUNT_LINES(__quex_assert(__this->_line_n == __That->_line_n));
    __QUEX_IF_COUNT_COLUMNS(__quex_assert(__this->_column_n == __That->_column_n));
#   endif
}


#ifdef QUEX_OPTION_TOKEN_TAKE_TEXT_SUPPORT
QUEX_INLINE bool 
TestAnalyzer_Token_take_text(TestAnalyzer_Token*            __this, 
                       const TestAnalyzer_lexatom_t* Begin, 
                       const TestAnalyzer_lexatom_t* End)
/* RETURNS: true -- if the token claims ownership over the given memory.
 *          false -- if no ownership is claimed.                             */
{
#   define self       (*__this)
#   ifdef  LexemeNull
#   error  "Error LexemeNull shall not be defined here."
#   endif
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    (void)__this;
    (void)Begin;
    (void)End;

#   line 66 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"


#       if 0
        /* Hint for debug: To check take_text change "#if 0" to "#if 1" */
        {
            const TestAnalyzer_lexatom_t* it = (void*)0x0;
            printf("previous:  '");
            if( self.text != LexemeNull ) {
                for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
                printf("%04X.", (int)*it);
            }
            printf("'\n");
            printf("take_text: '");
            for(it = Begin; it != End; ++it) printf("%04X.", (int)*it);
            printf("%04X.", (int)*it);
            printf("'\n");
        }
#       endif

        if( self.text != LexemeNull ) {
            QUEXED(MemoryManager_free)((void*)self.text, E_MemoryObjectType_TEXT);
        }
        if( Begin != LexemeNull ) {
            __quex_assert(End >= Begin);
            self.text = TestAnalyzer_lexeme_clone(Begin, (size_t)(End - Begin));
            if( ! self.text ) self.text = LexemeNull;
            *((TestAnalyzer_lexatom_t*)(self.text + (End - Begin))) = (TestAnalyzer_lexatom_t)0;
        } else {
            self.text = LexemeNull;
        }

#       if 0
        /* Hint for debug: To check take_text change "#if 0" to "#if 1"       */
        {
            const TestAnalyzer_lexatom_t* it = 0x0;
            printf("after:     '");
            if( self.text != LexemeNull ) { 
                for(it = self.text; *it ; ++it) printf("%04X.", (int)*it);
                printf("%04X.", (int)*it);
            }
            printf("'\n");
        }
#       endif

        /* This token copied the text from the chunk into the string, 
         * so we do not claim ownership over it.                             */
        return false;
   

#   line 604 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
    /* Default: no ownership.                                                */
    return false;
}
#endif

#ifdef QUEX_OPTION_TOKEN_REPETITION_SUPPORT
QUEX_INLINE size_t 
TestAnalyzer_Token_repetition_n_get(TestAnalyzer_Token* __this)
{
#   define self        (*__this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    (void)__this;

#   line 123 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       return self.number;
   

#   line 626 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}

QUEX_INLINE void 
TestAnalyzer_Token_repetition_n_set(TestAnalyzer_Token* __this, size_t N)
{
#   define self        (*__this)
#   define LexemeNull  (&TestAnalyzer_LexemeNull)
    (void)__this;
    (void)N;

#   line 119 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

       self.number = N;
   

#   line 645 "TestAnalyzer.h"

#   undef  LexemeNull
#   undef  self
}
#endif /* QUEX_OPTION_TOKEN_REPETITION_SUPPORT */

QUEX_INLINE const char*
TestAnalyzer_Token_map_id_to_name(const TestAnalyzer_token_id_t TokenID)
{
   switch( TokenID ) {
   default: {
       return "<NUMERIC VALUE OF TOKEN-ID UNDEFINED>";
   }

   case QUEX_TKN_TERMINATION:    return "<TERMINATION>";
   case QUEX_TKN_UNINITIALIZED:  return "<UNINITIALIZED>";
#  if defined(QUEX_OPTION_INDENTATION_TRIGGER)
   case QUEX_TKN_INDENT:         return "<INDENT>";
   case QUEX_TKN_DEDENT:         return "<DEDENT>";
   case QUEX_TKN_NODENT:         return "<NODENT>";
#  endif
   case QUEX_TKN_X:             return "X";


   }
}


#   line 127 "/home/fschaef/prj/quex/trunk/quex/code_base/token/CDefault.qx"

        const char* 
        TestAnalyzer_Token_get_string(TestAnalyzer_Token* me, char*   buffer, size_t  BufferSize) 
        {
            const char*  token_id_str = TestAnalyzer_Token_map_id_to_name(me->id);
            const char*  BufferEnd    = buffer + BufferSize;
            char*        writerator   = 0;

            if( ! BufferSize ) return NULL;

            /* Token Type */
            writerator = buffer; 
            writerator += __QUEX_STD_strlcpy(writerator, token_id_str, 
                                             BufferEnd - writerator);

            /* Opening Quote */
            if( BufferEnd - writerator > 2 ) {
                *writerator++ = ' ';
                *writerator++ = '\'';
            }

            /* The String */
            writerator = TestAnalyzer_lexeme_to_pretty_char(me->text, writerator, BufferEnd);

            /* Closing Quote */
            if( BufferEnd - writerator > 1 ) {
                *writerator++ = '\'';
            }
            *writerator = '\0';
            return buffer;
        }

#include <test_environment/converter-from-lexeme.i>
#include <test_environment/lib/lexeme_base.i>
   

#   line 711 "TestAnalyzer.h"


#endif /* __QUEX_INCLUDE_GUARD__TOKEN__GENERATED____TESTANALYZER_TOKEN_I */

#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
