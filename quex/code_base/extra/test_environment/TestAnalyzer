/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical FSM class TestAnalyzer and its memento class.
 * (5) Constructor and init core of TestAnalyzer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.68.2.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____TESTANALYZER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__

#include "TestAnalyzer-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* TestAnalyzer */
    typedef void  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must precede the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content ___________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */

extern bool UserConstructor_UnitTest_return_value;
extern bool UserReset_UnitTest_return_value;
extern bool UserMementoPack_UnitTest_return_value;


/* END: _______________________________________________________________________*/

#include <quex/code_base/analyzer/headers>

#include "TestAnalyzer-token_ids"
#include "TestAnalyzer-token"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_M) = 0
};

extern QUEX_NAME(Mode)  QUEX_NAME(M);


extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

extern  void QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern  bool QUEX_NAME(M_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
extern  void QUEX_NAME(M_on_buffer_before_change)(void* aux);
extern  void QUEX_NAME(M_on_buffer_overflow)(void* aux);
extern  void QUEX_NAME(M_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
extern  void QUEX_NAME(M_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
extern  void QUEX_NAME(M_on_indentation)(QUEX_TYPE_ANALYZER* me, QUEX_TYPE_INDENTATION Indentation, QUEX_TYPE_LEXATOM* Lexeme);
#endif


typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG QUEX_NAME(Memento_tag) {
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    char*                           __input_name;
    QUEX_NAME(Buffer)               buffer;

    struct QUEX_NAME(Mode_tag)*     __current_mode_p; 
    QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
    QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
    QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
    bool                            _indentation_handler_active_f;
#   endif
#   if defined(QUEX_OPTION_INCLUDE_STACK)
    struct QUEX_NAME(Memento_tag)*  _parent_memento;
#   endif
    /* __( END: Data Members )________________________________________________*/

    QUEX_NAME(Memento_tag)()  {} /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {} /* con- and destruction of user members.     */

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/
} QUEX_NAME(Memento);

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG TestAnalyzer {
public:
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    QUEX_NAME(Buffer)               buffer;
    QUEX_NAME(TokenQueue)           _token_queue;  
    QUEX_NAME(ModeStack)            _mode_stack;

    E_Error                         error_code;
    char*                           __input_name;

    QUEX_NAME(Mode)*                __current_mode_p; 
    /* Shortcut to current mode's analyzer function.                          */
    QUEX_NAME(AnalyzerFunctionP)    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
    /* Backup of analyzer's function pointer => mode change detection.        */
    QUEX_NAME(AnalyzerFunctionP)    DEBUG_analyzer_function_at_entry;
#   endif
#   if defined(QUEX_OPTION_COUNTER)
    QUEX_NAME(Counter)              counter;
#   endif
#   ifdef QUEX_OPTION_INDENTATION_TRIGGER
    bool                            _indentation_handler_active_f;
#   endif
#   if defined(QUEX_OPTION_INCLUDE_STACK)
    struct QUEX_NAME(Memento_tag)*  _parent_memento;
#   endif
    /* __( END: Data Members )________________________________________________*/
private:
    TestAnalyzer(const TestAnalyzer&) {}
    void resources_absent_mark()
         { QUEX_NAME(resources_absent_mark)(this); }

public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_LEXATOM    char_type;

    /*__( Constructors )________________________________________________________
     *                                                                        */
    TestAnalyzer()
         { QUEX_NAME(resources_absent_mark)(this); error_code = E_Error_Uninitialized; }

    TestAnalyzer(const char*      Filename, 
                  QUEX_NAME(Converter)* Converter = 0) 
         { QUEX_NAME(from_file_name)(this, Filename, Converter); }

    TestAnalyzer(QUEX_NAME(ByteLoader)*  byte_loader, 
                  QUEX_NAME(Converter)*        Converter = 0) 
         { QUEX_NAME(from_ByteLoader)(this, byte_loader, Converter); }

    TestAnalyzer(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                  size_t                  BufferMemorySize,
                  QUEX_TYPE_LEXATOM*      BufferEndOfContentP = 0x0)
         { QUEX_NAME(from_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /* Named placement-new functions.                                         */
    static TestAnalyzer* from_file_name(const char*           Filename, 
                                              QUEX_NAME(Converter)* Converter = 0) 
         { return new TestAnalyzer(Filename, Converter); }

    static TestAnalyzer* from_ByteLoader(QUEX_NAME(ByteLoader)*  byte_loader, 
                                               QUEX_NAME(Converter)*   Converter = 0) 
         { return new TestAnalyzer(byte_loader, Converter); }

    static TestAnalyzer* from_memory(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                                           size_t             BufferMemorySize,
                                           QUEX_TYPE_LEXATOM* BufferEndOfContentP = 0x0)
         { return new TestAnalyzer(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~TestAnalyzer()
         { QUEX_NAME(destruct)(this); }

    /*__( Reset )_______________________________________________________________
     *                                                                        */
    bool reset()
         { return QUEX_NAME(reset)(this); }
    bool reset(const char*            FileName, 
               QUEX_NAME(Converter)*  Converter = 0)
         { return QUEX_NAME(reset_file_name)(this, FileName, Converter); }

    bool reset(QUEX_NAME(ByteLoader)*  byte_loader, 
               QUEX_NAME(Converter)*   Converter = 0)
         { return QUEX_NAME(reset_ByteLoader)(this, byte_loader, Converter); }

    bool reset(QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
               size_t             BufferMemorySize,
               QUEX_TYPE_LEXATOM* BufferEndOfContentP)  
         { return QUEX_NAME(reset_memory)(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    void collect_user_memory(QUEX_TYPE_LEXATOM** user_memory_p)
         { return QUEX_NAME(collect_user_memory)(this, user_memory_p); }

    /*__( Include Handling )____________________________________________________
     *                                                                        */
#   ifdef QUEX_OPTION_INCLUDE_STACK
    bool include_push(const char*             FileName, 
                      QUEX_NAME(Converter)*   Converter = 0)
         { return QUEX_NAME(include_push_file_name)(this, FileName, Converter); }
    bool include_push(const char*             InputName, 
                      QUEX_NAME(ByteLoader)*  byte_loader, 
                      QUEX_NAME(Converter)*   Converter)  /* != 0 to avoid ambiguity. */
         { return QUEX_NAME(include_push_ByteLoader)(this, InputName, byte_loader, Converter); }
    bool include_push(const char*        InputName, 
                      QUEX_TYPE_LEXATOM* BufferMemoryBegin, 
                      size_t             BufferMemorySize,
                      QUEX_TYPE_LEXATOM* BufferEndOfContentP)  
         { return QUEX_NAME(include_push_memory)(this, InputName, BufferMemoryBegin, 
                                                 BufferMemorySize, BufferEndOfContentP); }
    bool include_pop()
         { return QUEX_NAME(include_pop)(this); }
    void include_stack_delete()
         { QUEX_NAME(include_stack_delete)(this); }
    bool include_detect_recursion(const char* InputName)
         { return QUEX_NAME(include_detect_recursion)(this, InputName); }
#   endif

    /*__( Analysis => Receiving Tokens )________________________________________
     *                                                                        */
    void receive(QUEX_TYPE_TOKEN** token_pp)    { QUEX_NAME(MF_receive)(this, token_pp); }

    QUEX_TYPE_TOKEN*  token_p()                 { return QUEX_NAME(MF_token_p)(this); }

    void send(QUEX_TYPE_TOKEN_ID Id)            { QUEX_NAME(MF_send)(this, Id); }
    void send_n(QUEX_TYPE_TOKEN_ID Id, 
                size_t             RepetitionN) { QUEX_NAME(MF_send_n)(this, Id, RepetitionN); }
    bool send_text(QUEX_TYPE_TOKEN_ID Id,
                   QUEX_TYPE_LEXATOM* BeginP, 
                   QUEX_TYPE_LEXATOM* EndP)     { return QUEX_NAME(MF_send_text)(this, Id, BeginP, EndP); }
    bool send_string(QUEX_TYPE_TOKEN_ID Id,
                     QUEX_TYPE_LEXATOM* ZeroTerminatedString) { return QUEX_NAME(MF_send_string)(this, Id, ZeroTerminatedString); }

    bool token_queue_is_empty()       
    { return QUEX_NAME(token_queue_is_empty)(this); }

    void token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, 
                                   QUEX_TYPE_TOKEN** end)
    { QUEX_NAME(token_queue_remainder_get)(this, begin, end); }

    void token_queue_swap(QUEX_TYPE_TOKEN** queue, size_t* size); 

    const char* input_name()                          
         { return QUEX_NAME(input_name)(this); }
    bool        input_name_set(const char* InputName) 
         { return QUEX_NAME(input_name_set)(this, InputName); }

    /*__( Modes )_______________________________________________________________
     *                                                                        */
    QUEX_NAME(Mode)&      mode()            
         { return *QUEX_NAME(get_mode)(this); }
    int                   mode_id() const   
         { return QUEX_NAME(get_mode_id)(this); }
    const char*           mode_name() const 
         { return QUEX_NAME(get_mode_name)(this); }
    QUEX_NAME(Mode)&      map_mode_id_to_mode(const int ModeId)
         { return *(QUEX_NAME(map_mode_id_to_mode)(this, ModeId)); }
    int                   map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const
         { return QUEX_NAME(map_mode_to_mode_id)(this, &Mode); }

    void set_mode_brutally(const int ModeId)
         { QUEX_NAME(set_mode_brutally_by_id)(this, ModeId); }
    void set_mode_brutally(const QUEX_NAME(Mode)& Mode)
         { QUEX_NAME(set_mode_brutally)(this, ((QUEX_NAME(Mode)*)&Mode)); }
    void enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode)
         { QUEX_NAME(enter_mode)(this, &TargetMode); }
    void operator<<(const int ModeId)
         { enter_mode(*(QUEX_NAME(map_mode_id_to_mode)(this, ModeId))); }
    void operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode)
         { enter_mode(Mode); }
    void pop_mode()
         { QUEX_NAME(pop_mode)(this); }
    void pop_drop_mode()
         { QUEX_NAME(pop_drop_mode)(this); }
    void push_mode(QUEX_NAME(Mode)& new_mode)
         { QUEX_NAME(push_mode)(this, &new_mode); }
private:
    /* Befriend all modes                                                     */
    friend  void QUEX_NAME(M_analyzer_function)(QUEX_TYPE_ANALYZER* me);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend  bool QUEX_NAME(M_has_base)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend  bool QUEX_NAME(M_has_entry_from)(const QUEX_NAME(Mode)* mode);
#endif
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend  bool QUEX_NAME(M_has_exit_to)(const QUEX_NAME(Mode)* mode);
#endif
    friend  void QUEX_NAME(M_on_buffer_before_change)(void* aux);
    friend  void QUEX_NAME(M_on_buffer_overflow)(void* aux);
    friend  void QUEX_NAME(M_on_entry)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
    friend  void QUEX_NAME(M_on_exit)(QUEX_TYPE_ANALYZER* me, const QUEX_NAME(Mode)* mode);
#ifdef QUEX_OPTION_INDENTATION_TRIGGER
    friend  void QUEX_NAME(M_on_indentation)(QUEX_TYPE_ANALYZER* me, QUEX_TYPE_INDENTATION Indentation, QUEX_TYPE_LEXATOM* Lexeme);
#endif
  

public:
    /*__( Access to Buffer )____________________________________________________
     *                                                                        */
    QUEX_TYPE_LEXATOM*    lexeme_start_pointer_get()
         { return QUEX_NAME(lexeme_start_pointer_get)(this); }

    QUEX_TYPE_LEXATOM*    input_pointer_get()
         { return QUEX_NAME(input_pointer_get)(this); }

    void input_pointer_set(QUEX_TYPE_LEXATOM* InputP)
         { return QUEX_NAME(input_pointer_set)(this, InputP); }

    /* Activate/deactivate byte order reversion (big-/little-endian)          */
    bool byte_order_reversion()
         { return QUEX_NAME(byte_order_reversion)(this); }
    void byte_order_reversion_set(bool Value)
         { return QUEX_NAME(byte_order_reversion_set)(this, Value); }

    /*__( Line/Column Counter )________________________________________________
     *                                                                       */
#   ifdef  QUEX_OPTION_COUNTER_LINE
    size_t      line_number() const            { return line_number_at_begin(); }
    size_t      line_number_at_begin() const   { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const     { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)      { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COUNTER_COLUMN
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)    { counter._column_number_at_end = X; }
#   endif
    /*__( Indentation )________________________________________________________
     *                                                                       */
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                  { return counter._indentation_stack.back - counter._indentation_stack.front + 1; }
#   endif

    /*__( Navigation: Tell/Seek )______________________________________________
     *                                                                       */
    size_t      tell()                                 { return QUEX_NAME(MF_tell)(this); }
    void        seek(const size_t CharacterIndex)      { QUEX_NAME(MF_seek)(this, CharacterIndex); }
    void        seek_forward(const size_t CharacterN)  { QUEX_NAME(MF_seek_forward)(this, CharacterN); }
    void        seek_backward(const size_t CharacterN) { QUEX_NAME(MF_seek_backward)(this, CharacterN); }
                
    void        undo()                         { return QUEX_NAME(MF_undo)(this); }
    void        undo_n(size_t DeltaN_Backward) { return QUEX_NAME(MF_undo_n)(this, DeltaN_Backward); }
                
public:
    bool        resources_absent()
    { return QUEX_NAME(resources_absent)(this); }

    /*__( General Information )________________________________________________
     *                                                                       */
    const char* version() const
    { return QUEX_NAME(version)((QUEX_TYPE_ANALYZER*)this); }

    void        print_this()
    { QUEX_NAME(print_this)(this); }

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

public:
    // Token sending happens only via 'self_send*(...)' macros
};

QUEX_NAMESPACE_MAIN_CLOSE



#include <quex/code_base/analyzer/headers.i>
/* START: User defined header content _________________________________________
 *        The 'footer' content relies on class definitions made above.        */



#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TESTANALYZER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER

QUEX_NAMESPACE_MAIN_OPEN

bool
QUEX_NAME(user_constructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_M)]  == &(QUEX_NAME(M)));


#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/
return UserConstructor_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_destructor)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

bool
QUEX_NAME(user_reset)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's 'reset' ______________________________________________________*/
return UserReset_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_print)(QUEX_TYPE_ANALYZER* me)
{
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

#ifdef QUEX_OPTION_INCLUDE_STACK

bool
QUEX_NAME(user_memento_pack)(QUEX_TYPE_ANALYZER* me, 
                             const char*         InputName, 
                             QUEX_NAME(Memento)* memento) 
{
    (void)me; (void)memento; (void)InputName;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'pack' _______________________________________________*/
return UserMementoPack_UnitTest_return_value;
/* END: _______________________________________________________________________*/
#undef self
    return true;
}

void
QUEX_NAME(user_memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                               QUEX_NAME(Memento)*  memento)
{
    (void)me; (void)memento;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE




bool UserConstructor_UnitTest_return_value = true;
bool UserReset_UnitTest_return_value       = true;
bool UserMementoPack_UnitTest_return_value = true;
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
#ifndef QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER
#include "TestAnalyzer-token"
QUEX_NAMESPACE_TOKEN_OPEN
QUEX_TYPE_LEXATOM   QUEX_NAME_TOKEN(LexemeNull) = (QUEX_TYPE_LEXATOM)0;
QUEX_NAMESPACE_TOKEN_CLOSE
#endif /* QUEX_OPTION_UNIT_TEST_NO_IMPLEMENTATION_IN_HEADER */
